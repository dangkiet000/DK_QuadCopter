
AVRASM ver. 2.2.6  F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\main.asm Fri Mar 03 00:23:39 2017

[builtin](2): Including file 'F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\m8def.inc'
F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\main.asm(60): Including file 'F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\m8def.inc'
F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\main.asm(90): Including file 'F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\DK.inc'
F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\main.asm(4103): Including file 'F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\boot.inc'
[builtin](2): Including file 'F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\m8def.inc'
F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\main.asm(60): Including file 'F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\m8def.inc'
F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\main.asm(90): Including file 'F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\DK.inc'
F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\main.asm(4103): Including file 'F:\My_Projects\QuadCopter\DK_QuadCopter\ESC\MyCode\DK_ESC\DK_ESC\boot.inc'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-08-25 21:00 ******* Source: ATmega8.xml *************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m8def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega8
                                 ;* Date              : 2011-08-25
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega8
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M8DEF_INC_
                                 #define _M8DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega8
                                 #pragma AVRPART ADMIN PART_NAME ATmega8
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x93
                                 .equ	SIGNATURE_002	= 0x07
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	GICR	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCR	= 0x37
                                 .equ	TWCR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	SFIOR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	ASSR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	UBRRH	= 0x20
                                 .equ	UCSRC	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR	= 0x0c
                                 .equ	UCSRA	= 0x0b
                                 .equ	UCSRB	= 0x0a
                                 .equ	UBRRL	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCL	= 0x04
                                 .equ	ADCH	= 0x05
                                 .equ	TWDR	= 0x03
                                 .equ	TWAR	= 0x02
                                 .equ	TWSR	= 0x01
                                 .equ	TWBR	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; GICR - General Interrupt Control Register
                                 .equ	GIMSK	= GICR	; For compatibility
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; GIFR - General Interrupt Flag Register
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 
                                 ; TCCR0 - Timer/Counter0 Control Register
                                 .equ	CS00	= 0	; Clock Select0 bit 0
                                 .equ	CS01	= 1	; Clock Select0 bit 1
                                 .equ	CS02	= 2	; Clock Select0 bit 2
                                 
                                 ; TCNT0 - Timer Counter 0
                                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	FOC1B	= 2	; Force Output Compare 1B
                                 .equ	FOC1A	= 3	; Force Output Compare 1A
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	CTC1	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 ; TCCR2 - Timer/Counter2 Control Register
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Output Mode bit 0
                                 .equ	COM21	= 5	; Compare Output Mode bit 1
                                 .equ	WGM20	= 6	; Waveform Genration Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2 - Timer/Counter2 Output Compare Register
                                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                                 
                                 
                                 ; ***** USART ************************
                                 ; UDR - USART I/O Data Register
                                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSRA - USART Control and Status Register A
                                 .equ	USR	= UCSRA	; For compatibility
                                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                                 .equ	U2X	= 1	; Double the USART transmission speed
                                 .equ	UPE	= 2	; Parity Error
                                 .equ	PE	= UPE	; For compatibility
                                 .equ	DOR	= 3	; Data overRun
                                 .equ	FE	= 4	; Framing Error
                                 .equ	UDRE	= 5	; USART Data Register Empty
                                 .equ	TXC	= 6	; USART Transmitt Complete
                                 .equ	RXC	= 7	; USART Receive Complete
                                 
                                 ; UCSRB - USART Control and Status Register B
                                 .equ	UCR	= UCSRB	; For compatibility
                                 .equ	TXB8	= 0	; Transmit Data Bit 8
                                 .equ	RXB8	= 1	; Receive Data Bit 8
                                 .equ	UCSZ2	= 2	; Character Size
                                 .equ	CHR9	= UCSZ2	; For compatibility
                                 .equ	TXEN	= 3	; Transmitter Enable
                                 .equ	RXEN	= 4	; Receiver Enable
                                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSRC - USART Control and Status Register C
                                 .equ	UCPOL	= 0	; Clock Polarity
                                 .equ	UCSZ0	= 1	; Character Size
                                 .equ	UCSZ1	= 2	; Character Size
                                 .equ	USBS	= 3	; Stop Bit Select
                                 .equ	UPM0	= 4	; Parity Mode Bit 0
                                 .equ	UPM1	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL	= 6	; USART Mode Select
                                 .equ	URSEL	= 7	; Register Select
                                 
                                 .equ	UBRRHI	= UBRRH	; For compatibility
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EEWEE	= EEMWE	; For compatibility
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 .equ	SM0	= 4	; Sleep Mode Select
                                 .equ	SM1	= 5	; Sleep Mode Select
                                 .equ	SM2	= 6	; Sleep Mode Select
                                 .equ	SE	= 7	; Sleep Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	MCUSR	= MCUCSR	; For compatibility
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; SPMCR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read-While-Write Section Read Enable
                                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PUD	= 2	; Pull-up Disable
                                 .equ	ADHSM	= 4	; ADC High Speed Mode
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	WTDON	= 6	; Enable watchdog
                                 .equ	RSTDISBL	= 7	; Disable reset
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0060
                                 .equ	SRAM_SIZE	= 1024
                                 .equ	RAMEND	= 0x045f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x01ff
                                 .equ	EEPROMEND	= 0x01ff
                                 .equ	EEADRBITS	= 9
                                 #pragma AVRPART MEMORY PROG_FLASH 8192
                                 #pragma AVRPART MEMORY EEPROM 512
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xc00
                                 .equ	NRWW_STOP_ADDR	= 0xfff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xbff
                                 .equ	PAGESIZE	= 32
                                 .equ	FIRSTBOOTSTART	= 0xf80
                                 .equ	SECONDBOOTSTART	= 0xf00
                                 .equ	THIRDBOOTSTART	= 0xe00
                                 .equ	FOURTHBOOTSTART	= 0xc00
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                                 .equ	OC2addr	= 0x0003	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0004	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                                 .equ	OVF0addr	= 0x0009	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x000a	; Serial Transfer Complete
                                 .equ	URXCaddr	= 0x000b	; USART, Rx Complete
                                 .equ	UDREaddr	= 0x000c	; USART Data Register Empty
                                 .equ	UTXCaddr	= 0x000d	; USART, Tx Complete
                                 .equ	ADCCaddr	= 0x000e	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x000f	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0010	; Analog Comparator
                                 .equ	TWIaddr	= 0x0011	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0012	; Store Program Memory Ready
                                 
                                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                                 
                                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                                 
                                 #endif  /* _M8DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; DK_ESC.asm
                                 ;
                                 ; Created: 3/3/2017 12:21:39 AM
                                 ; Author : Administrator
                                 ;
                                 
                                 ;**** **** **** **** ****
                                 ;
                                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                                 ;
                                 ;1. Da ich alles kostenlos zur Verfgung stelle, gebe ich keinerlei Garantie
                                 ;   und bernehme auch keinerlei Haftung fr die Folgen der Benutzung.
                                 ;
                                 ;2. Die Software ist ausschlielich zur privaten Nutzung bestimmt. Ich
                                 ;   habe nicht geprft, ob bei gewerblicher Nutzung irgendwelche Patentrechte
                                 ;   verletzt werden oder sonstige rechtliche Einschrnkungen vorliegen.
                                 ;
                                 ;3. Jeder darf nderungen vornehmen, z.B. um die Funktion seinen Bedrfnissen
                                 ;   anzupassen oder zu erweitern. Ich wrde mich freuen, wenn ich weiterhin als
                                 ;   Co-Autor in den Unterlagen erscheine und mir ein Link zur entprechenden Seite
                                 ;   (falls vorhanden) mitgeteilt wird.
                                 ;
                                 ;4. Auch nach den nderungen sollen die Software weiterhin frei sein, d.h. kostenlos bleiben.
                                 ;
                                 ;!! Wer mit den Nutzungbedingungen nicht einverstanden ist, darf die Software nicht nutzen !!
                                 ;
                                 ; tp-18a
                                 ; October 2004
                                 ; autor: Bernhard Konze
                                 ; email: bernhard.konze@versanet.de
                                 ;--
                                 ; Based on upon Bernhard's "tp-18a" and others; see
                                 ; http://home.versanet.de/~b-konze/blc_18a/blc_18a.htm
                                 ; Copyright (C) 2004 Bernhard Konze
                                 ; Copyright (C) 2011-2012 Simon Kirby and other contributors
                                 ; NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK. Always test
                                 ; without propellers! Please respect Bernhard Konze's license above.
                                 ;--
                                 ; WARNING: I have blown FETs on Turnigy Plush 18A ESCs in previous versions
                                 ; of this code with my modifications. Some bugs have since been fixed, such
                                 ; as leaving PWM enabled while busy-looping forever outside of ISR code.
                                 ; However, this does run with higher PWM frequency than most original code,
                                 ; so higher FET temperatures may occur! USE AT YOUR OWN RISK, and maybe see
                                 ; how it compares and let me know!
                                 ;
                                 ; WARNING: This does not check temperature or voltage ADC inputs.
                                 ;
                                 ; NOTE: We do 16-bit PWM on timer2 at full CPU clock rate resolution, using
                                 ; tcnt2h to simulate the high byte. An input FULL to STOP range of 800 plus
                                 ; a MIN_DUTY of 56 (a POWER_RANGE of 856) gives 800 unique PWM steps at an
                                 ; about 18kHz on a 16MHz CPU clock. The output frequency is slightly lower
                                 ; than F_CPU / POWER_RANGE due to cycles used in the interrupt as TCNT2 is
                                 ; reloaded.
                                 ;
                                 ; Simon Kirby <sim@simulated.ca>
                                 ;
                                 ;-- Device ----------------------------------------------------------------
                                 ;
                                 .include "m8def.inc"
                                 
                                 ;***** Created: 2011-08-25 21:00 ******* Source: ATmega8.xml *************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m8def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega8
                                 ;* Date              : 2011-08-25
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega8
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M8DEF_INC_
                                 #endif  /* _M8DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 ;
                                 ; 8K Bytes of In-System Self-Programmable Flash
                                 ; 512 Bytes EEPROM
                                 ; 1K Byte Internal SRAM
                                 ;
                                 ;-- Fuses -----------------------------------------------------------------
                                 ;
                                 ; Old fuses for internal RC oscillator at 8MHz were lfuse=0xa4 hfuse=0xdf,
                                 ; but since we now set OSCCAL to 0xff (about 16MHz), running under 4.5V is
                                 ; officially out of spec. We'd better set the brown-out detection to 4.0V.
                                 ; The resulting code works with or without external 16MHz oscillators.
                                 ; Boards with external oscillators can use lfuse=0x3f.
                                 ;
                                 ; If the boot loader is enabled, the last nibble of the hfuse should be set
                                 ; to 'a' or '2' to also enable EESAVE - save EEPROM on chip erase. This is
                                 ; a 512-word boot flash section (0xe00), and enable BOOTRST to jump to it.
                                 ; Setting these fuses actually has no harm even without the boot loader,
                                 ; since 0xffff is nop, and it will just nop-sled around into normal code.
                                 ;
                                 ; Suggested fuses with 4.0V brown-out voltage:
                                 ; Without external oscillator: avrdude -U lfuse:w:0x24:m -U hfuse:w:0xda:m
                                 ;    With external oscillator: avrdude -U lfuse:w:0x3f:m -U hfuse:w:0xca:m
                                 ;
                                 ; Don't set WDTON if using the boot loader. We will enable it on start.
                                 ;
                                 ;-- Board -----------------------------------------------------------------
                                 ;
                                 ; The following only works with avra or avrasm2.
                                 ; For avrasm32, just comment out all but the include you need.
                                 #include "DK.inc"	
                                 
                                 ;* Birdie 70A with all FETs on PORTD        *
                                 ;* All FETs is N-Type                       *
                                 ;* Use 1 INT0                               *
                                 ;* Original fuses are lfuse:0xbf hfuse:0xc1 *
                                 ;********************************************
                                 
                                 .equ	F_CPU		= 16000000
                                 .equ	USE_INT0	= 1
                                 .equ	USE_I2C		= 0
                                 .equ	USE_UART	= 0
                                 .equ	USE_ICP		= 0
                                 
                                 ;.equ    DEAD_LOW_NS     = 450	; May work on some boards, but be careful!
                                 ;.equ    DEAD_HIGH_NS    = 8000
                                 ;.equ	   CHECK_HARDWARE	 = 1
                                 
                                 ;******************************************
                                 ; PORT D definitions                      *
                                 ;******************************************
                                 .equ	ApFET		= 0	;o High-side A
                                 .equ	AnFET		= 1	;o Low-side A
                                 
                                 .equ	BpFET		= 4	;o High-side B
                                 .equ	BnFET		= 3	;o Low-side B
                                 
                                 .equ	CpFET		= 5	;o High-side C
                                 .equ	CnFET		= 7	;o Low-side C
                                 
                                 .equ	c_comp		= 6	;i common comparator input (AIN0)
                                 .equ	rcp_in		= 2	;i r/c pulse input
                                 
                                 .equ	INIT_PD		= 0
                                 .equ	DIR_PD		= (1<<ApFET)+(1<<BpFET)+(1<<CpFET)+(1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                                 
                                 .equ	ApFET_port	= PORTD
                                 .equ	BpFET_port	= PORTD
                                 .equ	CpFET_port	= PORTD
                                 .equ	AnFET_port	= PORTD
                                 .equ	BnFET_port	= PORTD
                                 .equ	CnFET_port	= PORTD
                                 
                                 ;******************************************
                                 ; PORT C definitions                      *
                                 ;******************************************
                                 .equ	mux_voltage	= 7	; ADC7 voltage input (47k from Vbat, 4.7k to gnd, 10.10V in -> .918V at ADC7)
                                 ;.equ			= 6	; ADC6
                                 ;.equ			= 5	; ADC5
                                 .equ	mux_c		= 4	; ADC4 phase input
                                 .equ	mux_b		= 3	; ADC3 phase input
                                 .equ	mux_a		= 2	; ADC2 phase input
                                 ;.equ			= 1	; ADC1
                                 ;.equ			= 0	; ADC0
                                 
                                 .equ	O_POWER		= 470
                                 .equ	O_GROUND	= 47
                                 
                                 .equ	INIT_PC		= 0
                                 .equ	DIR_PC		= 0
                                 
                                 ;******************************************
                                 ; PORT B definitions                      *
                                 ;******************************************
                                 ;.equ			= 7
                                 ;.equ			= 6
                                 ;.equ			= 5	(sck stk200 interface)
                                 ;.equ			= 4	(miso stk200 interface)
                                 ;.equ			= 3	(mosi stk200 interface)
                                 ;.equ			= 2
                                 ;.equ			= 1
                                 ;.equ			= 0
                                 
                                 .equ	INIT_PB		= 0
                                 .equ	DIR_PB		= 0
                                 
                                 /*
                                 #if defined(afro_esc)
                                 #include "afro.inc"		; AfroESC (ICP PWM, I2C, UART)
                                 #elif defined(afro2_esc)
                                 #include "afro2.inc"		; AfroESC 2 (ICP PWM, I2C, UART)
                                 #elif defined(afro_hv_esc)
                                 #include "afro_hv.inc"		; AfroESC HV with drivers (ICP PWM, I2C, UART)
                                 #elif defined(afro_nfet_esc)
                                 #include "afro_nfet.inc"	; AfroESC 3 with all nFETs (ICP PWM, I2C, UART)
                                 #elif defined(afro_pr0_esc)
                                 #include "afro_pr0.inc"		; AfroESC prototype rev0 with NCP5911 (ICP PWM)
                                 #elif defined(afro_pr1_esc)
                                 #include "afro_pr1.inc"		; AfroESC prototype rev1 with NCP5911 (ICP PWM)
                                 #elif defined(arctictiger_esc)
                                 #include "arctictiger.inc"	; Arctic Tiger 30A ESC with all nFETs (ICP PWM)
                                 #elif defined(birdie70a_esc)
                                 #include "birdie70a.inc"	; Birdie 70A with all nFETs (INT0 PWM)
                                 #elif defined(mkblctrl1_esc)
                                 #include "mkblctrl1.inc"	; MK BL-Ctrl v1.2 (ICP PWM, I2C, UART, high side PWM, sense hack)
                                 #elif defined(bs_esc)
                                 #include "bs.inc"		; HobbyKing BlueSeries / Mystery (INT0 PWM)
                                 #elif defined(bs_nfet_esc)
                                 #include "bs_nfet.inc"		; HobbyKing BlueSeries / Mystery with all nFETs (INT0 PWM)
                                 #elif defined(bs40a_esc)
                                 #include "bs40a.inc"		; HobbyKing BlueSeries / Mystery 40A (INT0 PWM)
                                 #elif defined(dlu40a_esc)
                                 #include "dlu40a.inc"		; Pulso Advance Plus 40A DLU40A inverted-PWM-opto (INT0 PWM)
                                 #elif defined(dlux_esc)
                                 #include "dlux.inc"		; HobbyKing Dlux Turnigy ESC 20A
                                 #elif defined(diy0_esc)
                                 #include "diy0.inc"		; HobbyKing DIY Open ESC (unreleased rev 0)
                                 #elif defined(dys_nfet_esc)
                                 #include "dys_nfet.inc"		; DYS 30A ESC with all nFETs (ICP PWM, I2C, UART)
                                 #elif defined(hk200a_esc)
                                 #include "hk200a.inc"		; HobbyKing SS Series 190-200A with all nFETs (INT0 PWM)
                                 #elif defined(hm135a_esc)
                                 #include "hm135a.inc"		; Hacker/Jeti Master 135-O-F5B 135A inverted-PWM-opto (INT0 PWM)
                                 #elif defined(hxt200a_esc)
                                 #include "hxt200a.inc"		; HexTronik F3J HXT200A HV ESC (INT0 PWM, I2C, UART)
                                 #elif defined(kda_esc)
                                 #include "kda.inc"		; Keda/Multistar 12A, 20A, 30A (original) (inverted INT0 PWM)
                                 #elif defined(kda_8khz_esc)
                                 #include "kda_8khz.inc"		; Keda/Multistar 30A (early 2014) (inverted INT0 PWM)
                                 #elif defined(kda_nfet_esc)
                                 #include "kda_nfet.inc"		; Keda/Multistar 30A with all nFETs (inverted INT0 PWM)
                                 #elif defined(kda_nfet_ni_esc)
                                 #include "kda_nfet_ni.inc"	; Keda/Multistar/Sunrise ~30A with all nFETs (INT0 PWM)
                                 #elif defined(rb50a_esc)
                                 #include "rb50a.inc"		; Red Brick 50A with all nFETs (INT0 PWM)
                                 #elif defined(rb70a_esc)
                                 #include "rb70a.inc"		; Red Brick 70A with all nFETs (INT0 PWM)
                                 #elif defined(rct50a_esc)
                                 #include "rct50a.inc"		; RCTimer 50A (MLF version) with all nFETs (INT0 PWM)
                                 #elif defined(tbs_esc)
                                 #include "tbs.inc"		; TBS 30A ESC (Team BlackSheep) with all nFETs (ICP PWM, UART)
                                 #elif defined(tbs_hv_esc)
                                 #include "tbs_hv.inc"		; TBS high voltage ESC (Team BlackSheep) with all nFETs (ICP PWM, UART)
                                 #elif defined(tp_esc)
                                 #include "tp.inc"		; TowerPro 25A/HobbyKing 18A "type 1" (INT0 PWM)
                                 #elif defined(tp_8khz_esc)
                                 #include "tp_8khz.inc"		; TowerPro 25A/HobbyKing 18A "type 1" (INT0 PWM) at 8kHz PWM
                                 #elif defined(tp_i2c_esc)
                                 #include "tp_i2c.inc"		; TowerPro 25A/HobbyKing 18A "type 1" (I2C)
                                 #elif defined(tp_nfet_esc)
                                 #include "tp_nfet.inc"		; TowerPro 25A with all nFETs "type 3" (INT0 PWM)
                                 #elif defined(tp70a_esc)
                                 #include "tp70a.inc"		; TowerPro 70A with BL8003 FET drivers (INT0 PWM)
                                 #elif defined(tgy6a_esc)
                                 #include "tgy6a.inc"		; Turnigy Plush 6A (INT0 PWM)
                                 #elif defined(tgy_8mhz_esc)
                                 #include "tgy_8mhz.inc"		; TowerPro/Turnigy Basic/Plush "type 2" w/8MHz oscillator (INT0 PWM)
                                 #elif defined(tgy_esc)
                                 #include "tgy.inc"		; TowerPro/Turnigy Basic/Plush "type 2" (INT0 PWM)
                                 #else
                                 #error "Unrecognized board type."
                                 #endif*/
                                 
                                 .equ	CPU_MHZ		= F_CPU / 1000000
                                 
                                 .equ	BOOT_LOADER	= 1	; Include Turnigy USB linker STK500v2 boot loader on PWM input pin
                                 .equ	BOOT_JUMP	= 1	; Jump to any boot loader when PWM input stays high
                                 .equ	BOOT_START	= THIRDBOOTSTART
                                 
                                 .if !defined(COMP_PWM)
                                 .equ	COMP_PWM	= 0	; During PWM off, switch high side on (unsafe on some boards!)
                                 .endif
                                 .if !defined(DEAD_LOW_NS)
                                 .equ	DEAD_LOW_NS	= 300	; Low-side dead time w/COMP_PWM (62.5ns steps @ 16MHz, max 2437ns)
                                 .equ	DEAD_HIGH_NS	= 300	; High-side dead time w/COMP_PWM (62.5ns steps @ 16MHz, max roughly PWM period)
                                 .endif
                                 .equ	DEAD_TIME_LOW	= DEAD_LOW_NS * CPU_MHZ / 1000
                                 .equ	DEAD_TIME_HIGH	= DEAD_HIGH_NS * CPU_MHZ / 1000
                                 
                                 .if !defined(MOTOR_ADVANCE)
                                 .equ	MOTOR_ADVANCE	= 18	; Degrees of timing advance (0 - 30, 30 meaning no delay)
                                 .endif
                                 .if !defined(TIMING_OFFSET)
                                 .equ	TIMING_OFFSET	= 0	; Motor timing offset in microseconds
                                 .endif
                                 .equ	MOTOR_BRAKE	= 0	; Enable brake during neutral/idle ("motor drag" brake)
                                 .equ	LOW_BRAKE	= 0	; Enable brake on very short RC pulse ("thumb" brake like on Airtronics XL2P)
                                 .if !defined(MOTOR_REVERSE)
                                 .equ	MOTOR_REVERSE	= 0	; Reverse normal commutation direction
                                 .endif
                                 .equ	RC_PULS_REVERSE	= 0	; Enable RC-car style forward/reverse throttle
                                 .equ	RC_CALIBRATION	= 1	; Support run-time calibration of min/max pulse lengths
                                 .equ	SLOW_THROTTLE	= 0	; Limit maximum throttle jump to try to prevent overcurrent
                                 .equ	BEACON		= 1	; Beep periodically when RC signal is lost
                                 .equ	BEACON_IDLE	= 0	; Beep periodically if idle for a long period
                                 .if !defined(CHECK_HARDWARE)
                                 .equ	CHECK_HARDWARE	= 0	; Check for correct pin configuration, sense inputs, and functioning MOSFETs
                                 .endif
                                 .equ	CELL_MAX_DV	= 43	; Maximum battery cell deciV
                                 .equ	CELL_MIN_DV	= 35	; Minimum battery cell deciV
                                 .equ	CELL_COUNT	= 0	; 0: auto, >0: hard-coded number of cells (for reliable LVC > ~4S)
                                 .equ	BLIP_CELL_COUNT	= 0	; Blip out cell count before arming
                                 .equ	DEBUG_ADC_DUMP	= 0	; Output an endless loop of all ADC values (no normal operation)
                                 .equ	MOTOR_DEBUG	= 0	; Output sync pulses on MOSI or SCK, debug flag on MISO
                                 
                                 .equ	I2C_ADDR	= 0x50	; MK-style I2C address
                                 .equ	MOTOR_ID	= 1	; MK-style I2C motor ID, or UART motor number
                                 
                                 .equ	RCP_TOT		= 2	; Number of 65536us periods before considering rc pulse lost
                                 
                                 ; These are now defaults which can be adjusted via throttle calibration
                                 ; (stick high, stick low, (stick neutral) at start).
                                 ; These might be a bit wide for most radios, but lines up with POWER_RANGE.
                                 .equ	STOP_RC_PULS	= 1060	; Stop motor at or below this pulse length
                                 .equ	FULL_RC_PULS	= 1860	; Full speed at or above this pulse length
                                 .equ	MAX_RC_PULS	= 2400	; Throw away any pulses longer than this
                                 .equ	MIN_RC_PULS	= 768	; Throw away any pulses shorter than this
                                 .equ	MID_RC_PULS	= (STOP_RC_PULS + FULL_RC_PULS) / 2	; Neutral when RC_PULS_REVERSE = 1
                                 .equ	RCP_ALIAS_SHIFT	= 3	; Enable 1/8th PWM input alias ("oneshot125")
                                 .equ	BEEP_RCP_ERROR	= 0	; Beep at stop if invalid PWM pulses were received
                                 
                                 .if	RC_PULS_REVERSE
                                 .else
                                 .equ	RCP_DEADBAND	= 0
                                 .equ	PROGRAM_RC_PULS	= (STOP_RC_PULS + FULL_RC_PULS) / 2	; Normally 1460
                                 .endif
                                 
                                 .if	LOW_BRAKE
                                 .endif
                                 
                                 .equ	MAX_DRIFT_PULS	= 10	; Maximum jitter/drift microseconds during programming
                                 
                                 ; Minimum PWM on-time (too low and FETs won't turn on, hard starting)
                                 .if !defined(MIN_DUTY)
                                 .equ	MIN_DUTY	= 56 * CPU_MHZ / 16
                                 .endif
                                 
                                 ; Number of PWM steps (too high and PWM frequency drops into audible range)
                                 .if !defined(POWER_RANGE)
                                 .equ	POWER_RANGE	= 800 * CPU_MHZ / 16 + MIN_DUTY
                                 .endif
                                 
                                 .equ	MAX_POWER	= (POWER_RANGE-1)
                                 .equ	PWR_COOL_START	= (POWER_RANGE/24) ; Power limit while starting to reduce heating
                                 .equ	PWR_MIN_START	= (POWER_RANGE/6) ; Power limit while starting (to start)
                                 .equ	PWR_MAX_START	= (POWER_RANGE/4) ; Power limit while starting (if still not running)
                                 .equ	PWR_MAX_RPM1	= (POWER_RANGE/4) ; Power limit when running slower than TIMING_RANGE1
                                 .equ	PWR_MAX_RPM2	= (POWER_RANGE/2) ; Power limit when running slower than TIMING_RANGE2
                                 
                                 .equ	BRAKE_POWER	= MAX_POWER*2/3	; Brake force is exponential, so start fairly high
                                 .equ	BRAKE_SPEED	= 3		; Speed to reach MAX_POWER, 0 (slowest) - 8 (fastest)
                                 .equ	LOW_BRAKE_POWER	= MAX_POWER*2/3
                                 .equ	LOW_BRAKE_SPEED	= 5
                                 
                                 .equ	TIMING_MIN	= 0x8000 ; 8192us per commutation
                                 .equ	TIMING_RANGE1	= 0x4000 ; 4096us per commutation
                                 .equ	TIMING_RANGE2	= 0x2000 ; 2048us per commutation
                                 .equ	TIMING_RANGE3	= 0x1000 ; 1024us per commutation
                                 .equ	TIMING_MAX	= 0x0080 ; 32us per commutation (312,500eRPM)
                                 
                                 .equ	TIMEOUT_START	= 48000	; Timeout per commutation for ZC during starting
                                 .if !defined(START_DELAY_US)
                                 .equ	START_DELAY_US	= 0	; Initial post-commutation wait during starting
                                 .endif
                                 .equ	START_DSTEP_US	= 8	; Microseconds per start delay step
                                 .equ	START_DELAY_INC	= 15	; Wait step count increase (wraps in a byte)
                                 .equ	START_MOD_INC	= 4	; Start power modulation step count increase (wraps in a byte)
                                 .equ	START_MOD_LIMIT	= 48	; Value at which power is reduced to avoid overheating
                                 .equ	START_FAIL_INC	= 16	; start_tries step count increase (wraps in a byte, upon which we disarm)
                                 
                                 .equ	ENOUGH_GOODIES	= 12	; This many start cycles without timeout will transition to running mode
                                 .equ	ZC_CHECK_FAST	= 12	; Number of ZC check loops under which PWM noise should not matter
                                 .equ	ZC_CHECK_MAX	= POWER_RANGE / 32 ; Limit ZC checking to about 1/2 PWM interval
                                 .equ	ZC_CHECK_MIN	= 3
                                 
                                 .equ	T0CLK		= (1<<CS01)	; clk/8 == 2MHz
                                 .equ	T1CLK		= (1<<CS10)+(USE_ICP<<ICES1)+(USE_ICP<<ICNC1)	; clk/1 == 16MHz
                                 .equ	T2CLK		= (1<<CS20)	; clk/1 == 16MHz
                                 
                                 .equ	EEPROM_SIGN	= 31337		; Random 16-bit value
                                 .equ	EEPROM_OFFSET	= 0x80		; Offset into 512-byte space (why not)
                                 
                                 ; Conditional code inclusion
                                 .set	DEBUG_TX	= 0		; Output debugging on UART TX pin
                                 .set	ADC_READ_NEEDED	= 0		; Reading from ADCs
                                 
                                 ;**** **** **** **** ****
                                 ; Register Definitions
                                 .def	temp5		= r0		; aux temporary (L) (limited operations)
                                 .def	temp6		= r1		; aux temporary (H) (limited operations)
                                 .def	duty_l		= r2		; on duty cycle low, one's complement
                                 .def	duty_h		= r3		; on duty cycle high
                                 .def	off_duty_l	= r4		; off duty cycle low, one's complement
                                 .def	off_duty_h	= r5		; off duty cycle high
                                 .def	rx_l		= r6		; received throttle low
                                 .def	rx_h		= r7		; received throttle high
                                 .def	tcnt2h		= r8		; timer2 high byte
                                 .def	i_sreg		= r9		; status register save in interrupts
                                 .def	temp7		= r10		; really aux temporary (limited operations)
                                 .def	rc_timeout	= r11
                                 .def	sys_control_l	= r12		; duty limit low (word register aligned)
                                 .def	sys_control_h	= r13		; duty limit high
                                 .def	timing_duty_l	= r14		; timing duty limit low
                                 .def	timing_duty_h	= r15		; timing duty limit high
                                 .def	flags0		= r16	; state flags
                                 	.equ	OCT1_PENDING	= 0	; if set, output compare interrupt is pending
                                 	.equ	SET_DUTY	= 1	; if set when armed, set duty during evaluate_rc
                                 	.equ	RCP_ERROR	= 2	; if set, corrupted PWM input was seen
                                 	.equ	RCP_ALIAS	= 3	; if set, rc alias (shifted) range is active
                                 	.equ	EEPROM_RESET	= 4	; if set, reset EEPROM
                                 	.equ	EEPROM_WRITE	= 5	; if set, save settings to EEPROM
                                 	.equ	UART_SYNC	= 6	; if set, we are waiting for our serial throttle byte
                                 	.equ	NO_CALIBRATION	= 7	; if set, disallow calibration (unsafe reset cause)
                                 .def	flags1		= r17	; state flags
                                 	.equ	POWER_ON	= 0	; if set, switching fets is enabled
                                 	.equ	FULL_POWER	= 1	; 100% on - don't switch off, but do OFF_CYCLE working
                                 	.equ	I2C_MODE	= 2	; if receiving updates via I2C
                                 	.equ	UART_MODE	= 3	; if receiving updates via UART
                                 	.equ	EVAL_RC		= 4	; if set, evaluate rc command while waiting for OCT1
                                 	.equ	ACO_EDGE_HIGH	= 5	; if set, looking for ACO high - same bit position as ACO
                                 	.equ	STARTUP		= 6	; if set, startup-phase is active
                                 	.equ	REVERSE		= 7	; if set, do reverse commutation
                                 .def	flags2		= r18
                                 	.equ	A_FET		= 0	; if set, A FET is being PWMed
                                 	.equ	B_FET		= 1	; if set, B FET is being PWMed
                                 	.equ	C_FET		= 2	; if set, C FET is being PWMed
                                 	.equ	ALL_FETS	= (1<<A_FET)+(1<<B_FET)+(1<<C_FET)
                                 	.equ	TIMING_FAST	= 6	; if set, timing fits in 16 bits
                                 	.equ	SKIP_CPWM	= 7	; if set, skip complementary PWM (for short off period)
                                 ;.def			= r19
                                 .def	i_temp1		= r20		; interrupt temporary
                                 .def	i_temp2		= r21		; interrupt temporary
                                 .def	temp3		= r22		; main temporary (L)
                                 .def	temp4		= r23		; main temporary (H)
                                 .def	temp1		= r24		; main temporary (L), adiw-capable
                                 .def	temp2		= r25		; main temporary (H), adiw-capable
                                 
                                 ; XL: general temporary
                                 ; XH: general temporary
                                 ; YL: general temporary
                                 ; YH: general temporary
                                 ; ZL: Next PWM interrupt vector (low)
                                 ; ZH: Next PWM interrupt vector (high, stays at zero) -- used as "zero" register
                                 
                                 ;**** **** **** **** ****
                                 ; RAM Definitions
                                 .dseg				; DATA segment
                                 .org SRAM_START
                                 
000060                           orig_osccal:	.byte	1	; original OSCCAL value
000061                           goodies:	.byte	1	; Number of rounds without timeout
000062                           powerskip:	.byte	1	; Skip power through this number of steps
000063                           ocr1ax:		.byte	1	; 3rd byte of OCR1A
000064                           tcnt1x:		.byte	1	; 3rd byte of TCNT1
000065                           pwm_on_ptr:	.byte	1	; Next PWM ON vector
000066                           rct_boot:	.byte	1	; Counter which increments while rc_timeout is 0 to jump to boot loader
000067                           rct_beacon:	.byte	1	; Counter which increments while rc_timeout is 0 to disarm and beep occasionally
000068                           idle_beacon:	.byte	1	; Counter which increments while armed and idle to beep occasionally
000069                           last_tcnt1_l:	.byte	1	; last timer1 value
00006a                           last_tcnt1_h:	.byte	1
00006b                           last_tcnt1_x:	.byte	1
00006c                           l2_tcnt1_l:	.byte	1	; last last timer1 value
00006d                           l2_tcnt1_h:	.byte	1
00006e                           l2_tcnt1_x:	.byte	1
00006f                           timing_l:	.byte	1	; interval of 2 commutations
000070                           timing_h:	.byte	1
000071                           timing_x:	.byte	1
000072                           com_time_l:	.byte	1	; time of last commutation
000073                           com_time_h:	.byte	1
000074                           com_time_x:	.byte	1
000075                           start_delay:	.byte	1	; delay count after starting commutations before checking back-EMF
000076                           start_modulate:	.byte	1	; Start modulation counter (to reduce heating from PWR_MAX_START if stuck)
000077                           start_fail:	.byte   1	; Number of start_modulate loops for eventual failure and disarm
000078                           rcp_beep_count:	.byte	1	; Number of RC pulse error beeps
000079                           rc_duty_l:	.byte	1	; desired duty cycle
00007a                           rc_duty_h:	.byte	1
00007b                           fwd_scale_l:	.byte	1	; 16.16 multipliers to scale input RC pulse to POWER_RANGE
00007c                           fwd_scale_h:	.byte	1
00007d                           rev_scale_l:	.byte	1
00007e                           rev_scale_h:	.byte	1
00007f                           neutral_l:	.byte	1	; Offset for neutral throttle (in CPU_MHZ)
000080                           neutral_h:	.byte	1
                                 .if RCP_DEADBAND && defined(RCP_ALIAS_SHIFT)
                                 .endif
                                 .if LOW_BRAKE
                                 .endif
                                 .if USE_I2C
                                 .endif
000081                           motor_count:	.byte	1	; Motor number for serial control
000082                           brake_sub:	.byte	1	; Brake speed subtrahend (power of two)
000083                           brake_want:	.byte	1	; Type of brake desired
000084                           brake_active:	.byte	1	; Type of brake active
                                 ;**** **** **** **** ****
                                 ; The following entries are block-copied from/to EEPROM
000085                           eeprom_sig_l:	.byte	1
000086                           eeprom_sig_h:	.byte	1
000087                           puls_high_l:	.byte	1	; -,
000088                           puls_high_h:	.byte	1	;  |
000089                           puls_low_l:	.byte	1	;  |- saved pulse lengths during throttle calibration
00008a                           puls_low_h:	.byte	1	;  |  (order used by rc_prog)
00008b                           puls_neutral_l:	.byte	1	;  |
00008c                           puls_neutral_h:	.byte	1	; -'
                                 .if USE_I2C
                                 .endif
00008d                           eeprom_end:	.byte	1
                                 ;-----bko-----------------------------------------------------------------
                                 ;**** **** **** **** ****
                                 .cseg
                                 .org 0
                                 ;**** **** **** **** ****
                                 ; ATmega8 interrupts
                                 
                                 ;.equ	INT0addr=$001	; External Interrupt0 Vector Address
                                 ;.equ	INT1addr=$002	; External Interrupt1 Vector Address
                                 ;.equ	OC2addr =$003	; Output Compare2 Interrupt Vector Address
                                 ;.equ	OVF2addr=$004	; Overflow2 Interrupt Vector Address
                                 ;.equ	ICP1addr=$005	; Input Capture1 Interrupt Vector Address
                                 ;.equ	OC1Aaddr=$006	; Output Compare1A Interrupt Vector Address
                                 ;.equ	OC1Baddr=$007	; Output Compare1B Interrupt Vector Address
                                 ;.equ	OVF1addr=$008	; Overflow1 Interrupt Vector Address
                                 ;.equ	OVF0addr=$009	; Overflow0 Interrupt Vector Address
                                 ;.equ	SPIaddr =$00a	; SPI Interrupt Vector Address
                                 ;.equ	URXCaddr=$00b	; USART Receive Complete Interrupt Vector Address
                                 ;.equ	UDREaddr=$00c	; USART Data Register Empty Interrupt Vector Address
                                 ;.equ	UTXCaddr=$00d	; USART Transmit Complete Interrupt Vector Address
                                 ;.equ	ADCCaddr=$00e	; ADC Interrupt Vector Address
                                 ;.equ	ERDYaddr=$00f	; EEPROM Interrupt Vector Address
                                 ;.equ	ACIaddr =$010	; Analog Comparator Interrupt Vector Address
                                 ;.equ	TWIaddr =$011	; Irq. vector address for Two-Wire Interface
                                 ;.equ	SPMaddr =$012	; SPM complete Interrupt Vector Address
                                 ;.equ	SPMRaddr =$012	; SPM complete Interrupt Vector Address
                                 
                                 ;-----bko-----------------------------------------------------------------
                                 ; Reset and interrupt jump table
                                 ; When multiple interrupts are pending, the vectors are executed from top
                                 ; (ext_int0) to bottom.
000000 c4e3                      		rjmp reset	; reset
000001 c05d                      		rjmp rcp_int	; ext_int0
000002 9518                      		reti		; ext_int1
000003 9518                      		reti		; t2oc_int
000004 9409                      		ijmp		; t2ovfl_int
000005 c059                      		rjmp rcp_int	; icp1_int
000006 c036                      		rjmp t1oca_int	; t1oca_int
000007 9518                      		reti		; t1ocb_int
000008 c03e                      		rjmp t1ovfl_int	; t1ovfl_int
000009 9518                      		reti		; t0ovfl_int
00000a 9518                      		reti		; spi_int
00000b c073                      		rjmp urxc_int	; urxc
00000c 9518                      		reti		; udre
00000d 9518                      		reti		; utxc
00000e 9518                      		reti		; adc_int
00000f 9518                      		reti		; eep_int
000010 9518                      		reti		; aci_int
000011 c06d                      		rjmp i2c_int	; twi_int
000012 9518                      		reti		; spmc_int
                                 
                                 eeprom_defaults_w:
000013 7a69                      	.db low(EEPROM_SIGN), high(EEPROM_SIGN)
000014 7440                      	.db byte1(FULL_RC_PULS * CPU_MHZ), byte2(FULL_RC_PULS * CPU_MHZ)
000015 4240                      	.db byte1(STOP_RC_PULS * CPU_MHZ), byte2(STOP_RC_PULS * CPU_MHZ)
000016 5b40                      	.db byte1(MID_RC_PULS * CPU_MHZ), byte2(MID_RC_PULS * CPU_MHZ)
                                 .if USE_I2C
                                 .endif
                                 
                                 ;-- Instruction extension macros -----------------------------------------
                                 
                                 ; Add any 16-bit immediate to a register pair (@0:@1 += @2), no Z flag
                                 .macro adi2
                                 	.if byte1(-@2)
                                 		subi	@0, byte1(-@2)
                                 		sbci	@1, byte1(-byte2(@2 + 0xff))
                                 	.else
                                 		subi	@1, byte1(-byte2(@2 + 0xff))
                                 	.endif
                                 .endmacro
                                 
                                 ; Smaller version for r24 and above, Z flag not reliable
                                 .macro adiwx
                                 	.if !(@2 & 0xff) || (@2) & ~0x3f
                                 		adi2	@0, @1, @2
                                 	.else
                                 		adiw	@0, @2
                                 	.endif
                                 .endmacro
                                 
                                 ; Compare any 16-bit immediate from a register pair (@0:@1 -= @2, maybe clobbering @3)
                                 .macro cpiz2
                                 		cpi	@0, byte1(@2)
                                 	.if byte2(@2)
                                 		ldi	@3, byte2(@2)
                                 		cpc	@1, @3
                                 	.else
                                 		cpc	@1, ZH
                                 	.endif
                                 .endmacro
                                 
                                 ; Compare any 16-bit immediate from a register pair (@0:@1 -= @2, maybe clobbering @3), no Z flag
                                 ; Do not follow by Z flag tests like breq, brne, brlt, brge, brlo, brsh!
                                 ; The idea here is that the low byte being compared with (subtracted by)
                                 ; 0 will never set carry, so skipping it and cpi'ing the high byte is the
                                 ; same other than the result of the Z flag.
                                 .macro cpi2
                                 	.if byte1(@2)
                                 		cpiz2	@0, @1, @2, @3
                                 	.else
                                 		cpi	@1, byte2(@2)
                                 	.endif
                                 .endmacro
                                 
                                 ; Compare any 24-bit immediate from a register triplet (@0:@1:@2 -= @3, maybe clobbering @4)
                                 .macro cpiz3
                                 		cpi	@0, byte1(@3)
                                 	.if byte2(@3)
                                 		ldi	@4, byte2(@3)
                                 		cpc	@1, @4
                                 	.else
                                 		cpc	@1, ZH
                                 	.endif
                                 	.if byte3(@3)
                                 		ldi	@4, byte3(@3)
                                 		cpc	@2, @4
                                 	.else
                                 		cpc	@2, ZH
                                 	.endif
                                 .endmacro
                                 
                                 ; Compare any 24-bit immediate from a register triplet (@0:@1:@2 -= @3, maybe clobbering @4)
                                 ; May not set Z flag, as above.
                                 .macro cpi3
                                 	.if byte1(@3)
                                 		cpiz3	@0, @1, @2, @3, @4
                                 	.else
                                 		cpi2	@1, @2, @3 >> 8, @4
                                 	.endif
                                 .endmacro
                                 
                                 ; Subtract any 16-bit immediate from a register pair (@0:@1 -= @2), no Z flag
                                 .macro sbi2
                                 	.if byte1(@2)
                                 		subi	@0, byte1(@2)
                                 		sbci	@1, byte2(@2)
                                 	.else
                                 		subi	@1, byte2(@2)
                                 	.endif
                                 .endmacro
                                 
                                 ; Smaller version for r24 and above, Z flag not reliable
                                 .macro sbiwx
                                 	.if !(@2 & 0xff) || (@2) & ~0x3f
                                 		sbi2	@0, @1, @2
                                 	.else
                                 		sbiw	@0, @2
                                 	.endif
                                 .endmacro
                                 
                                 ; Load 2-byte immediate
                                 .macro ldi2
                                 		ldi	@0, byte1(@2)
                                 		ldi	@1, byte2(@2)
                                 .endmacro
                                 
                                 ; Load 3-byte immediate
                                 .macro ldi3
                                 		ldi	@0, byte1(@3)
                                 		ldi	@1, byte2(@3)
                                 		ldi	@2, byte3(@3)
                                 .endmacro
                                 
                                 ; Register out to any address (memory-mapped if necessary)
                                 .macro outr
                                 	.if @0 < 64
                                 		out	@0, @1
                                 	.else
                                 		sts	@0, @1
                                 	.endif
                                 .endmacro
                                 
                                 ; Register in from any address (memory-mapped if necessary)
                                 .macro inr
                                 	.if @1 < 64
                                 		in	@0, @1
                                 	.else
                                 		lds	@0, @1
                                 	.endif
                                 .endmacro
                                 
                                 ; Immediate out to any port (possibly via @2 as a temporary)
                                 .macro outi
                                 	.if @1
                                 		ldi	@2, @1
                                 		outr	@0, @2
                                 	.else
                                 		outr	@0, ZH
                                 	.endif
                                 .endmacro
                                 
                                 ;-- LED macros -----------------------------------------------------------
                                 
                                 .if !defined(red_led)
                                 	.macro RED_on
                                 	.endmacro
                                 	.macro RED_off
                                 	.endmacro
                                 .endif
                                 
                                 .if !defined(green_led)
                                 	.macro GRN_on
                                 	.endmacro
                                 	.macro GRN_off
                                 	.endmacro
                                 .endif
                                 
                                 .if !defined(blue_led)
                                 	.macro BLUE_on
                                 	.endmacro
                                 	.macro BLUE_off
                                 	.endmacro
                                 .endif
                                 
                                 ;-- FET driving macros ---------------------------------------------------
                                 ; Careful: "if" conditions split over multiple lines (with backslashes)
                                 ; work with arva, but avrasm2.exe silently produces wrong results.
                                 
                                 .if !defined(HIGH_SIDE_PWM)
                                 .equ HIGH_SIDE_PWM = 0
                                 .endif
                                 
                                 .if defined(AnFET)
                                 ; Traditional direct high and low side drive, inverted if INIT_Px is set.
                                 ; Dead-time insertion is supported for COMP_PWM.
                                 
                                 	.equ CPWM_SOFT = COMP_PWM
                                 
                                 	.macro FET_on
                                 		.if (INIT_PB & ((@0 == PORTB) << @1)) | (INIT_PC & ((@0 == PORTC) << @1)) | (INIT_PD & ((@0 == PORTD) << @1))
                                 		cbi	@0, @1
                                 		.else
                                 		sbi	@0, @1
                                 		.endif
                                 	.endmacro
                                 
                                 	.macro FET_off
                                 		.if (INIT_PB & ((@0 == PORTB) << @1)) | (INIT_PC & ((@0 == PORTC) << @1)) | (INIT_PD & ((@0 == PORTD) << @1))
                                 		sbi	@0, @1
                                 		.else
                                 		cbi	@0, @1
                                 		.endif
                                 	.endmacro
                                 
                                 	.macro AnFET_on
                                 		FET_on	AnFET_port, AnFET
                                 	.endmacro
                                 	.macro AnFET_off
                                 		FET_off	AnFET_port, AnFET
                                 	.endmacro
                                 	.macro ApFET_on
                                 		FET_on	ApFET_port, ApFET
                                 	.endmacro
                                 	.macro ApFET_off
                                 		FET_off	ApFET_port, ApFET
                                 	.endmacro
                                 	.macro BnFET_on
                                 		FET_on	BnFET_port, BnFET
                                 	.endmacro
                                 	.macro BnFET_off
                                 		FET_off	BnFET_port, BnFET
                                 	.endmacro
                                 	.macro BpFET_on
                                 		FET_on	BpFET_port, BpFET
                                 	.endmacro
                                 	.macro BpFET_off
                                 		FET_off	BpFET_port, BpFET
                                 	.endmacro
                                 	.macro CnFET_on
                                 		FET_on	CnFET_port, CnFET
                                 	.endmacro
                                 	.macro CnFET_off
                                 		FET_off	CnFET_port, CnFET
                                 	.endmacro
                                 	.macro CpFET_on
                                 		FET_on	CpFET_port, CpFET
                                 	.endmacro
                                 	.macro CpFET_off
                                 		FET_off	CpFET_port, CpFET
                                 	.endmacro
                                 
                                 	.macro PWM_FOCUS_A_on
                                 		.if COMP_PWM
                                 		cpse	temp3, temp4
                                 		PWM_COMP_A_on
                                 		.endif
                                 	.endmacro
                                 	.macro PWM_FOCUS_A_off
                                 		.if COMP_PWM
                                 		in	temp3, PWM_COMP_A_PORT_in
                                 		PWM_COMP_A_off
                                 		in	temp4, PWM_COMP_A_PORT_in
                                 		.endif
                                 	.endmacro
                                 	.macro PWM_FOCUS_B_on
                                 		.if COMP_PWM
                                 		cpse	temp3, temp4
                                 		PWM_COMP_B_on
                                 		.endif
                                 	.endmacro
                                 	.macro PWM_FOCUS_B_off
                                 		.if COMP_PWM
                                 		in	temp3, PWM_COMP_B_PORT_in
                                 		PWM_COMP_B_off
                                 		in	temp4, PWM_COMP_B_PORT_in
                                 		.endif
                                 	.endmacro
                                 	.macro PWM_FOCUS_C_on
                                 		.if COMP_PWM
                                 		cpse	temp3, temp4
                                 		PWM_COMP_C_on
                                 		.endif
                                 	.endmacro
                                 	.macro PWM_FOCUS_C_off
                                 		.if COMP_PWM
                                 		in	temp3, PWM_COMP_C_PORT_in
                                 		PWM_COMP_C_off
                                 		in	temp4, PWM_COMP_C_PORT_in
                                 		.endif
                                 	.endmacro
                                 
                                 	; For PWM state mirroring in commutation routines
                                 	.if HIGH_SIDE_PWM
                                 	.else
                                 		.equ	PWM_A_PORT_in = AnFET_port
                                 		.equ	PWM_B_PORT_in = BnFET_port
                                 		.equ	PWM_C_PORT_in = CnFET_port
                                 		.equ	PWM_COMP_A_PORT_in = ApFET_port
                                 		.equ	PWM_COMP_B_PORT_in = BpFET_port
                                 		.equ	PWM_COMP_C_PORT_in = CpFET_port
                                 	.endif
                                 
                                 	.macro PWM_ALL_off
                                 		.if HIGH_SIDE_PWM
                                 		all_pFETs_off @0
                                 		.else
                                 		all_nFETs_off @0
                                 		.endif
                                 	.endmacro
                                 
                                 	.macro all_pFETs_off
                                 	.if ApFET_port != BpFET_port || ApFET_port != CpFET_port
                                 		ApFET_off
                                 		BpFET_off
                                 		CpFET_off
                                 	.else
                                 		in	@0, ApFET_port
                                 		.if (INIT_PB & ((ApFET_port == PORTB) << ApFET)) | (INIT_PC & ((ApFET_port == PORTC) << ApFET)) | (INIT_PD & ((ApFET_port == PORTD) << ApFET))
                                 		sbr	@0, (1<<ApFET)+(1<<BpFET)+(1<<CpFET)
                                 		.else
                                 		cbr	@0, (1<<ApFET)+(1<<BpFET)+(1<<CpFET)
                                 		.endif
                                 		out	ApFET_port, @0
                                 	.endif
                                 	.endmacro
                                 
                                 	.macro all_nFETs_off
                                 	.if AnFET_port != BnFET_port || AnFET_port != CnFET_port
                                 		AnFET_off
                                 		BnFET_off
                                 		CnFET_off
                                 	.else
                                 		in	@0, AnFET_port
                                 		.if (INIT_PB & ((AnFET_port == PORTB) << AnFET)) | (INIT_PC & ((AnFET_port == PORTC) << AnFET)) | (INIT_PD & ((AnFET_port == PORTD) << AnFET))
                                 		sbr	@0, (1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                                 		.else
                                 		cbr	@0, (1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                                 		.endif
                                 		out	AnFET_port, @0
                                 	.endif
                                 	.endmacro
                                 
                                 	.macro nFET_brake
                                 	.if AnFET_port != BnFET_port || AnFET_port != CnFET_port
                                 		AnFET_on
                                 		BnFET_on
                                 		CnFET_on
                                 	.else
                                 		in	@0, AnFET_port
                                 		.if (INIT_PB & ((AnFET_port == PORTB) << AnFET)) | (INIT_PC & ((AnFET_port == PORTC) << AnFET)) | (INIT_PD & ((AnFET_port == PORTD) << AnFET))
                                 		cbr	@0, (1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                                 		.else
                                 		sbr	@0, (1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                                 		.endif
                                 		out	AnFET_port, @0
                                 	.endif
                                 	.endmacro
                                 
                                 .elif defined(ENABLE_ALL)
                                 		.if COMP_PWM
                                 		.endif
                                 		.if COMP_PWM
                                 		.endif
                                 		.if COMP_PWM
                                 		.endif
                                 		.if COMP_PWM
                                 		.endif
                                 		.if COMP_PWM
                                 		.endif
                                 		.if COMP_PWM
                                 		.endif
                                 	.if COMP_PWM || !HIGH_SIDE_PWM
                                 	.else
                                 	.endif
                                 		.if PWM_A_DDR != PWM_B_DDR || PWM_A_DDR != PWM_C_DDR
                                 		.else
                                 		.endif
                                 		.if PWM_A_PORT != PWM_B_PORT || PWM_A_PORT != PWM_C_PORT
                                 		.else
                                 		.endif
                                 		.if PWM_A_PORT != PWM_B_PORT || PWM_A_PORT != PWM_C_PORT
                                 		.else
                                 		.endif
                                 .endif
                                 
                                 ;-- Commutation drive macros ---------------------------------------------
                                 
                                 .if HIGH_SIDE_PWM
                                 .else
                                 	.macro COMMUTATE_A_on
                                 		ApFET_on
                                 	.endmacro
                                 	.macro COMMUTATE_A_off
                                 		ApFET_off
                                 	.endmacro
                                 	.macro COMMUTATE_B_on
                                 		BpFET_on
                                 	.endmacro
                                 	.macro COMMUTATE_B_off
                                 		BpFET_off
                                 	.endmacro
                                 	.macro COMMUTATE_C_on
                                 		CpFET_on
                                 	.endmacro
                                 	.macro COMMUTATE_C_off
                                 		CpFET_off
                                 	.endmacro
                                 .endif
                                 
                                 ;-- PWM macros -----------------------------------------------------------
                                 
                                 .macro PWM_A_on
                                 	.if !defined(AnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		AnFET_off
                                 	.elif HIGH_SIDE_PWM
                                 		ApFET_on
                                 	.else
                                 		AnFET_on
                                 	.endif
                                 .endmacro
                                 .macro PWM_A_off
                                 	.if !defined(AnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		AnFET_on
                                 	.elif HIGH_SIDE_PWM
                                 		ApFET_off
                                 	.else
                                 		AnFET_off
                                 	.endif
                                 .endmacro
                                 .macro PWM_A_clear
                                 		in	temp1, PWM_A_PORT_in
                                 	.if !defined(AnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		AnFET_off
                                 	.elif HIGH_SIDE_PWM
                                 		ApFET_off
                                 	.else
                                 		AnFET_off
                                 	.endif
                                 		in	temp2, PWM_A_PORT_in
                                 .endmacro
                                 .macro PWM_A_copy
                                 		cpse	temp1, temp2
                                 	.if !defined(AnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		AnFET_on
                                 	.elif HIGH_SIDE_PWM
                                 		ApFET_on
                                 	.else
                                 		AnFET_on
                                 	.endif
                                 .endmacro
                                 
                                 .macro PWM_B_on
                                 	.if !defined(BnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		BnFET_off
                                 	.elif HIGH_SIDE_PWM
                                 		BpFET_on
                                 	.else
                                 		BnFET_on
                                 	.endif
                                 .endmacro
                                 .macro PWM_B_off
                                 	.if !defined(BnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		BnFET_on
                                 	.elif HIGH_SIDE_PWM
                                 		BpFET_off
                                 	.else
                                 		BnFET_off
                                 	.endif
                                 .endmacro
                                 .macro PWM_B_clear
                                 		in	temp1, PWM_B_PORT_in
                                 	.if !defined(BnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		BnFET_off
                                 	.elif HIGH_SIDE_PWM
                                 		BpFET_off
                                 	.else
                                 		BnFET_off
                                 	.endif
                                 		in	temp2, PWM_B_PORT_in
                                 .endmacro
                                 .macro PWM_B_copy
                                 		cpse	temp1, temp2
                                 	.if !defined(BnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		BnFET_on
                                 	.elif HIGH_SIDE_PWM
                                 		BpFET_on
                                 	.else
                                 		BnFET_on
                                 	.endif
                                 .endmacro
                                 
                                 .macro PWM_C_on
                                 	.if !defined(CnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		CnFET_off
                                 	.elif HIGH_SIDE_PWM
                                 		CpFET_on
                                 	.else
                                 		CnFET_on
                                 	.endif
                                 .endmacro
                                 .macro PWM_C_off
                                 	.if !defined(CnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		CnFET_on
                                 	.elif HIGH_SIDE_PWM
                                 		CpFET_off
                                 	.else
                                 		CnFET_off
                                 	.endif
                                 .endmacro
                                 .macro PWM_C_clear
                                 		in	temp1, PWM_C_PORT_in
                                 	.if !defined(CnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		CnFET_off
                                 	.elif HIGH_SIDE_PWM
                                 		CpFET_off
                                 	.else
                                 		CnFET_off
                                 	.endif
                                 		in	temp2, PWM_C_PORT_in
                                 .endmacro
                                 .macro PWM_C_copy
                                 		cpse	temp1, temp2
                                 	.if !defined(CnFET) && COMP_PWM && HIGH_SIDE_PWM
                                 		CnFET_on
                                 	.elif HIGH_SIDE_PWM
                                 		CpFET_on
                                 	.else
                                 		CnFET_on
                                 	.endif
                                 .endmacro
                                 
                                 ;-- Complementary PWM macros ---------------------------------------------
                                 
                                 .if CPWM_SOFT
                                 		.if HIGH_SIDE_PWM
                                 		.else
                                 		.endif
                                 		.if HIGH_SIDE_PWM
                                 		.else
                                 		.endif
                                 		.if HIGH_SIDE_PWM
                                 		.else
                                 		.endif
                                 		.if HIGH_SIDE_PWM
                                 		.else
                                 		.endif
                                 		.if HIGH_SIDE_PWM
                                 		.else
                                 		.endif
                                 		.if HIGH_SIDE_PWM
                                 		.else
                                 		.endif
                                 .endif
                                 
                                 ;-- RC pulse setup and edge handling macros ------------------------------
                                 
                                 .if USE_ICP
                                 .elif USE_INT0
                                 .macro rcp_int_enable
                                 		ldi	@0, (1<<INT0)	; enable ext_int0
                                 		out	GICR, @0
                                 .endmacro
                                 .macro rcp_int_disable
                                 		out	GICR, ZH	; disable ext_int0
                                 .endmacro
                                 .if USE_INT0 == 1
                                 .macro rcp_int_rising_edge
                                 		ldi	@0, (1<<ISC01)+(1<<ISC00)
                                 		out	MCUCR, @0	; set next int0 to rising edge
                                 .endmacro
                                 .macro rcp_int_falling_edge
                                 		ldi	@0, (1<<ISC01)
                                 		out	MCUCR, @0	; set next int0 to falling edge
                                 .endmacro
                                 .elif USE_INT0 == 2
                                 .endif
                                 .endif
                                 
                                 ;-- Analog comparator sense macros ---------------------------------------
                                 ; We enable and disable the ADC to override ACME when one of the sense
                                 ; pins is AIN1 instead of an ADC pin. In the future, this will allow
                                 ; reading from the ADC at the same time.
                                 
                                 .macro comp_init
                                 		in	@0, SFIOR
                                 		sbr	@0, (1<<ACME)	; set Analog Comparator Multiplexer Enable
                                 		out	SFIOR, @0
                                 	.if defined(mux_a) && defined(mux_b) && defined(mux_c)
                                 		cbi	ADCSRA, ADEN	; Disable ADC to make sure ACME works
                                 	.endif
                                 .endmacro
                                 .macro comp_adc_disable
                                 	.if !defined(mux_a) || !defined(mux_b) || !defined(mux_c)
                                 		cbi	ADCSRA, ADEN	; Disable ADC if we enabled it to get AIN1
                                 	.endif
                                 .endmacro
                                 .macro comp_adc_enable
                                 		sbi	ADCSRA, ADEN	; Eisable ADC to effectively disable ACME
                                 .endmacro
                                 .macro set_comp_phase_a
                                 	.if defined(mux_a)
                                 		ldi	@0, mux_a	; set comparator multiplexer to phase A
                                 		out	ADMUX, @0
                                 		comp_adc_disable
                                 	.else
                                 		comp_adc_enable
                                 	.endif
                                 .endmacro
                                 .macro set_comp_phase_b
                                 	.if defined(mux_b)
                                 		ldi	@0, mux_b	; set comparator multiplexer to phase B
                                 		out	ADMUX, @0
                                 		comp_adc_disable
                                 	.else
                                 		comp_adc_enable
                                 	.endif
                                 .endmacro
                                 .macro set_comp_phase_c
                                 	.if defined(mux_c)
                                 		ldi	@0, mux_c	; set comparator multiplexer to phase C
                                 		out	ADMUX, @0
                                 		comp_adc_disable
                                 	.else
                                 		comp_adc_enable
                                 	.endif
                                 .endmacro
                                 
                                 ;-- Timing and motor debugging macros ------------------------------------
                                 
                                 .macro flag_on
                                 	.if MOTOR_DEBUG && (DIR_PB & (1<<4)) == 0
                                 		sbi	PORTB, 4
                                 	.endif
                                 .endmacro
                                 .macro flag_off
                                 	.if MOTOR_DEBUG && (DIR_PB & (1<<4)) == 0
                                 		cbi	PORTB, 4
                                 	.endif
                                 .endmacro
                                 .macro sync_on
                                 	.if MOTOR_DEBUG && (DIR_PB & (1<<3)) == 0
                                 		sbi	PORTB, 3
                                 	.elif MOTOR_DEBUG && (DIR_PB & (1<<5)) == 0
                                 		sbi	PORTB, 5
                                 	.endif
                                 .endmacro
                                 .macro sync_off
                                 	.if MOTOR_DEBUG && (DIR_PB & (1<<3)) == 0
                                 		cbi	PORTB, 3
                                 	.elif MOTOR_DEBUG && (DIR_PB & (1<<5)) == 0
                                 		cbi	PORTB, 5
                                 	.endif
                                 .endmacro
                                 
                                 ; Short cycle delay without clobbering flags
                                 .equ	MAX_BUSY_WAIT_CYCLES	= 32
                                 .macro cycle_delay
                                 .if @0 >= MAX_BUSY_WAIT_CYCLES
                                 .error "cycle_delay too long"
                                 .endif
                                 .if @0 > 0
                                 	.if @0 & 1
                                 		nop
                                 	.endif
                                 	.if @0 & 2
                                 		rjmp	PC + 1
                                 	.endif
                                 	.if @0 & 4
                                 		rjmp	PC + 1
                                 		rjmp	PC + 1
                                 	.endif
                                 	.if @0 & 8
                                 		nop
                                 		rcall	wait_ret		; 3 cycles to call + 4 to return
                                 	.endif
                                 	.if @0 & 16
                                 		rjmp	PC + 1
                                 		rcall	wait_ret
                                 		rcall	wait_ret
                                 	.endif
                                 .endif
                                 .endmacro
                                 
                                 ;-----bko-----------------------------------------------------------------
                                 ; Timer2 overflow interrupt (output PWM) -- the interrupt vector actually
                                 ; "ijmp"s to Z, which should point to one of these entry points.
                                 ;
                                 ; We try to avoid clobbering (and thus needing to save/restore) flags;
                                 ; in, out, mov, ldi, cpse, etc. do not modify any flags, while dec does.
                                 ;
                                 ; We used to check the comparator (ACSR) here to help starting, since PWM
                                 ; switching is what introduces noise that affects the comparator result.
                                 ; However, timing of this is very sensitive to FET characteristics, and
                                 ; would work well on some boards but not at all on others without waiting
                                 ; another 100-200ns, which was enough to break other boards. So, instead,
                                 ; we do all of the ACSR sampling outside of the interrupt and do digital
                                 ; filtering. The AVR interrupt overhead also helps to shield the noise.
                                 ;
                                 ; We reload TCNT2 as the very last step so as to reduce PWM dead areas
                                 ; between the reti and the next interrupt vector execution, which still
                                 ; takes a good 4 (reti) + 4 (interrupt call) + 2 (ijmp) cycles. We also
                                 ; try to keep the switch on close to the start of pwm_on and switch off
                                 ; close to the end of pwm_aff to minimize the power bump at full power.
                                 ;
                                 ; pwm_*_high and pwm_again are called when the particular on/off cycle
                                 ; is longer than will fit in 8 bits. This is tracked in tcnt2h.
                                 
                                 .if MOTOR_BRAKE || LOW_BRAKE
                                 .endif
                                 
                                 .if DEAD_TIME_HIGH > 7
                                 .else
                                 .equ	EXTRA_DEAD_TIME_HIGH = 0
                                 .endif
                                 
                                 pwm_on_fast_high:
                                 .if CPWM_SOFT && EXTRA_DEAD_TIME_HIGH > MAX_BUSY_WAIT_CYCLES
                                 .endif
                                 
                                 pwm_on_high:
000017 b69f                      		in	i_sreg, SREG
000018 948a                      		dec	tcnt2h
000019 f409                      		brne	pwm_on_again
00001a e2e1                      		ldi	ZL, pwm_on
00001b be9f                      pwm_on_again:	out	SREG, i_sreg
00001c 9518                      		reti
                                 
                                 pwm_again:
00001d b69f                      		in	i_sreg, SREG
00001e 948a                      		dec	tcnt2h
00001f be9f                      		out	SREG, i_sreg
000020 9518                      		reti
                                 
                                 pwm_on:
                                 .if CPWM_SOFT
                                 	.if EXTRA_DEAD_TIME_HIGH > MAX_BUSY_WAIT_CYCLES
                                 		.if high(EXTRA_DEAD_TIME_HIGH)
                                 		.else
                                 		.endif
                                 	.else
                                 	.endif
                                 .endif
                                 pwm_on_fast:
000021 fd20                      		sbrc	flags2, A_FET
000022 9a91                      		PWM_A_on
000023 fd21                      		sbrc	flags2, B_FET
000024 9a93                      		PWM_B_on
000025 fd22                      		sbrc	flags2, C_FET
000026 9a97                      		PWM_C_on
000027 e2ed                      		ldi	ZL, pwm_off
000028 2c83                      		mov	tcnt2h, duty_h
000029 bc24                      		out	TCNT2, duty_l
00002a 9518                      		reti
                                 
                                 pwm_wdr:					; Just reset watchdog
00002b 95a8                      		wdr
00002c 9518                      		reti
                                 
                                 pwm_off:
00002d 128f                      		cpse	tcnt2h, ZH		; 2 cycles to skip when tcnt2h is 0
00002e cfee                      		rjmp	pwm_again
00002f 95a8                      		wdr				; 1 cycle: watchdog reset
000030 fd11                      		sbrc	flags1, FULL_POWER	; 2 cycles to skip if not full power
000031 cfef                      		rjmp	pwm_on			; None of this off stuff if full power
000032 91e0 0065                 		lds	ZL, pwm_on_ptr		; 2 cycles
000034 2c85                      		mov	tcnt2h, off_duty_h	; 1 cycle
000035 fd20                      		sbrc	flags2, A_FET		; 2 cycles if skip, 1 cycle otherwise
000036 9891                      		PWM_A_off			; 2 cycles (off at 12 cycles from entry)
000037 fd21                      		sbrc	flags2, B_FET		; Offset by 2 cycles here,
000038 9893                      		PWM_B_off			; but still equal on-time
000039 fd22                      		sbrc	flags2, C_FET
00003a 9897                      		PWM_C_off
00003b bc44                      		out	TCNT2, off_duty_l	; 1 cycle
                                 		.if CPWM_SOFT
                                 		.if DEAD_TIME_LOW > 9
                                 		.else
                                 		.endif
                                 		.endif
00003c 9518                      		reti				; 4 cycles
                                 
                                 .if high(pwm_off)
                                 .endif
                                 ;-----bko-----------------------------------------------------------------
                                 ; timer1 output compare interrupt
00003d b69f                      t1oca_int:	in	i_sreg, SREG
00003e 9140 0063                 		lds	i_temp1, ocr1ax
000040 5041                      		subi	i_temp1, 1
000041 f408                      		brcc	t1oca_int1
000042 7f0e                      		cbr	flags0, (1<<OCT1_PENDING)	; signal OCT1A passed
000043 9340 0063                 t1oca_int1:	sts	ocr1ax, i_temp1
000045 be9f                      		out	SREG, i_sreg
000046 9518                      		reti
                                 ;-----bko-----------------------------------------------------------------
                                 ; timer1 overflow interrupt (happens every 4096s)
000047 b69f                      t1ovfl_int:	in	i_sreg, SREG
000048 9140 0064                 		lds	i_temp1, tcnt1x
00004a 9543                      		inc	i_temp1
00004b 9340 0064                 		sts	tcnt1x, i_temp1
                                 		.if BEACON_IDLE
                                 		.endif
00004d 704f                      		andi	i_temp1, 15			; Every 16 overflows
00004e f419                      		brne	t1ovfl_int1
00004f 20bb                      		tst	rc_timeout
000050 f019                      		breq	t1ovfl_int2
000051 94ba                      		dec	rc_timeout
000052 be9f                      t1ovfl_int1:	out	SREG, i_sreg
000053 9518                      		reti
000054 9140 0066                 t1ovfl_int2:	lds	i_temp1, rct_boot
000056 9543                      		inc	i_temp1
000057 9340 0066                 		sts	rct_boot, i_temp1
000059 9140 0067                 		lds	i_temp1, rct_beacon
00005b 9543                      		inc	i_temp1
00005c 9340 0067                 		sts	rct_beacon, i_temp1
00005e cff3                      		rjmp	t1ovfl_int1
                                 ;-----bko-----------------------------------------------------------------
                                 ; NOTE: This interrupt uses the 16-bit atomic timer read/write register
                                 ; by reading TCNT1L and TCNT1H, so this interrupt must be disabled before
                                 ; any other 16-bit timer options happen that might use the same register
                                 ; (see "Accessing 16-bit registers" in the Atmel documentation)
                                 ; icp1 = rc pulse input, if enabled
                                 rcp_int:
                                 	.if USE_ICP || USE_INT0
                                 		.if USE_ICP
                                 		.else
00005f b54c                      		in	i_temp1, TCNT1L		; get timer1 values
000060 b55d                      		in	i_temp2, TCNT1H
                                 		.if USE_INT0 == 1
000061 9b82                      		sbis	PIND, rcp_in		; evaluate edge of this interrupt
                                 		.else
                                 		.endif
                                 		.endif
000062 c00d                      		rjmp	falling_edge
                                 rising_edge:
000063 b69f                      		in	i_sreg, SREG
                                 		; Stuff this rise time plus MAX_RC_PULS into OCR1B.
                                 		; We use this both to save the time it went high and
                                 		; to get an interrupt to indicate high timeout.
000064 565a                      		adiwx	i_temp1, i_temp2, MAX_RC_PULS * CPU_MHZ
000065 bd59                      		out	OCR1BH, i_temp2
000066 bd48                      		out	OCR1BL, i_temp1
000067 e042
000068 bf45                      		rcp_int_falling_edge i_temp1	; Set next int to falling edge
000069 e048                      		ldi	i_temp1, (1<<OCF1B)	; Clear OCF1B flag
00006a bf48                      		out	TIFR, i_temp1
00006b be9f                      		out	SREG, i_sreg
00006c 9518                      		reti
                                 
                                 rcpint_fail:
00006d b69f                      		in	i_sreg, SREG
00006e 6004                      		sbr	flags0, (1<<RCP_ERROR)
00006f c00b                      		rjmp	rcpint_exit
                                 
                                 falling_edge:
000070 b698                      		in	i_sreg, TIFR
000071 fc93                      		sbrc	i_sreg, OCF1B		; Too long high would set OCF1B
000072 cffa                      		rjmp	rcpint_fail
000073 b69f                      		in	i_sreg, SREG
000074 013a                      		movw	rx_l, i_temp1		; Guaranteed to be valid, store immediately
000075 b548                      		in	i_temp1, OCR1BL		; No atomic temp register used to read OCR1* registers
000076 b559                      		in	i_temp2, OCR1BH
000077 5956                      		sbi2	i_temp1, i_temp2, MAX_RC_PULS * CPU_MHZ	; Put back to start time
000078 1a64                      		sub	rx_l, i_temp1		; Subtract start time from current time
000079 0a75                      		sbc	rx_h, i_temp2
                                 .if MAX_RC_PULS * CPU_MHZ > 0xffff
                                 .endif
00007a 6110                      		sbr	flags1, (1<<EVAL_RC)
00007b e043
00007c bf45                      rcpint_exit:	rcp_int_rising_edge i_temp1	; Set next int to rising edge
00007d be9f                      		out	SREG, i_sreg
00007e 9518                      		reti
                                 	.endif
                                 ;-----bko-----------------------------------------------------------------
                                 ; MK BL-Ctrl v1, v2 compatible input control
                                 ; Ctrl-click Settings in MKTool for reversing and additional settings
                                 i2c_int:
                                 	.if USE_I2C
                                 	.endif
                                 ;-----bko-----------------------------------------------------------------
                                 urxc_int:
                                 ; This is Bernhard's serial protocol implementation in the UART
                                 ; version here: http://home.versanet.de/~b-konze/blc_6a/blc_6a.htm
                                 ; This seems to be implemented for a project described here:
                                 ; http://www.control.aau.dk/uav/reports/10gr833/10gr833_student_report.pdf
                                 ; The UART runs at 38400 baud, N81. Input is ignored until >= 0xf5
                                 ; is received, where we start counting to MOTOR_ID, at which
                                 ; the received byte is used as throttle input. 0 is neutral,
                                 ; >= 200 is FULL_POWER.
                                 	.if USE_UART
                                 	.endif
                                 ;-----bko-----------------------------------------------------------------
                                 ; beeper: timer0 is set to 1s/count
00007f e590                      beep_f1:	ldi	temp2, 80
000080 ec78                      		ldi	temp4, 200
                                 		RED_on
                                 		BLUE_on
000081 9a94                      beep_f1_on:	BpFET_on
000082 9a91                      		AnFET_on
000083 d017                      		rcall	beep
000084 f7e1                      		brne	beep_f1_on
                                 		BLUE_off
                                 		RED_off
000085 9508                      		ret
                                 
000086 e694                      beep_f2:	ldi	temp2, 100
000087 eb74                      		ldi	temp4, 180
                                 		GRN_on
                                 		BLUE_on
000088 9a95                      beep_f2_on:	CpFET_on
000089 9a93                      		BnFET_on
00008a d010                      		rcall	beep
00008b f7e1                      		brne	beep_f2_on
                                 		BLUE_off
                                 		GRN_off
00008c 9508                      		ret
                                 
00008d e798                      beep_f3:	ldi	temp2, 120
00008e ea70                      		ldi	temp4, 160
                                 		BLUE_on
00008f 9a90                      beep_f3_on:	ApFET_on
000090 9a97                      		CnFET_on
000091 d009                      		rcall	beep
000092 f7e1                      		brne	beep_f3_on
                                 		BLUE_off
000093 9508                      		ret
                                 
000094 e89c                      beep_f4:	ldi	temp2, 140
000095 e87c                      beep_f4_freq:	ldi	temp4, 140
                                 beep_f4_fets:	RED_on
                                 		GRN_on
                                 		BLUE_on
000096 9a95                      beep_f4_on:	CpFET_on
000097 9a91                      		AnFET_on
000098 d002                      		rcall	beep
000099 f7e1                      		brne	beep_f4_on
                                 		BLUE_off
                                 		GRN_off
                                 		RED_off
00009a 9508                      		ret
                                 
                                 		; Fall through
                                 ;-----bko-----------------------------------------------------------------
                                 ; Interrupts no longer need to be disabled to beep, but the PWM interrupt
                                 ; must be muted first
00009b bff2                      beep:		out	TCNT0, ZH
00009c b782                      beep1:		in	temp1, TCNT0
00009d 3280                      		cpi	temp1, 2*CPU_MHZ	; 32s on
00009e f3e8                      		brlo	beep1
00009f b362
0000a0 7c6e
0000a1 bb62                      		all_pFETs_off temp3
0000a2 b362
0000a3 7765
0000a4 bb62                      		all_nFETs_off temp3
0000a5 e160                      		ldi	temp3, CPU_MHZ
0000a6 bff2                      beep2:		out	TCNT0, ZH
0000a7 95a8                      		wdr
0000a8 b782                      beep3:		in	temp1, TCNT0
0000a9 1787                      		cp	temp1, temp4
0000aa f3e8                      		brlo	beep3
0000ab 956a                      		dec	temp3
0000ac f7c9                      		brne	beep2
0000ad 959a                      		dec	temp2
0000ae 9508                      		ret
                                 
0000af d000                      wait240ms:	rcall	wait120ms
0000b0 d000                      wait120ms:	rcall	wait60ms
0000b1 d000                      wait60ms:	rcall	wait30ms
0000b2 e09f                      wait30ms:	ldi	temp2, 15
0000b3 e160                      wait1:		ldi	temp3, CPU_MHZ
0000b4 bff2                      wait2:		out	TCNT0, ZH
0000b5 e081                      		ldi	temp1, (1<<TOV0)	; Clear TOV0 by setting it
0000b6 bf88                      		out	TIFR, temp1
0000b7 95a8                      		wdr
0000b8 b788                      wait3:		in	temp1, TIFR
0000b9 ff80                      		sbrs	temp1, TOV0
0000ba cffd                      		rjmp	wait3
0000bb 956a                      		dec	temp3
0000bc f7b9                      		brne	wait2
0000bd 959a                      		dec	temp2
0000be f7a1                      		brne	wait1
0000bf 9508                      wait_ret:	ret
                                 
                                 ;-- EEPROM functions -----------------------------------------------------
                                 ; Interrupts must be disabled to avoid Z conflicts and content changes.
                                 eeprom_check_reset:
                                 	; Check EEPROM signature
0000c0 9180 0085                 		lds	temp1, eeprom_sig_l
0000c2 9190 0086                 		lds	temp2, eeprom_sig_h
0000c4 5689                      		subi	temp1, low(EEPROM_SIGN)
0000c5 479a                      		sbci	temp2, high(EEPROM_SIGN)
0000c6 f039                      		breq	eeprom_good
                                 
                                 	; Signature not good: set defaults in RAM, but do not write
                                 	; to the EEPROM until we actually set something non-default
0000c7 e8c5
0000c8 e0d0                      eeprom_reset1:	ldi2	YL, YH, eeprom_sig_l
0000c9 e2e6                      		ldi	ZL, low(eeprom_defaults_w << 1)
0000ca 9185                      eeprom_reset2:	lpm	temp1, Z+
0000cb 9389                      		st	Y+, temp1
0000cc 38cd                      		cpi	YL, low(eeprom_end)
0000cd f7e1                      		brne	eeprom_reset2
0000ce 9508                      eeprom_good:	ret
                                 
                                 .if USE_I2C
                                 .endif
                                 
                                 ;-----bko-----------------------------------------------------------------
                                 ; Read from or write to the EEPROM block. To avoid duplication, we use the
                                 ; global interrupts flag (I) to enable writing versus reading mde. Only
                                 ; changed bytes are written. We restore OSCCAL to the boot-time value as
                                 ; the EEPROM timing is affected by it. We always return by falling through
                                 ; to osccal_set.
                                 eeprom_read_block:				; When interrupts disabled
                                 eeprom_write_block:				; When interrupts enabled
0000cf 9180 0060                 		lds	temp1, orig_osccal
0000d1 bf81                      		out	OSCCAL, temp1
0000d2 7d0f                      		cbr	flags0, (1<<EEPROM_WRITE)
0000d3 e8c5
0000d4 e0d0                      		ldi2	YL, YH, eeprom_sig_l
0000d5 e880
0000d6 e090                      		ldi2	temp1, temp2, EEPROM_OFFSET
0000d7 95a8                      eeprom_rw1:	wdr
0000d8 99e1                      		sbic	EECR, EEWE
0000d9 cffd                      		rjmp	eeprom_rw1		; Loop while writing EEPROM
0000da b767                      		in	temp3, SPMCR
0000db fd60                      		sbrc	temp3, SPMEN
0000dc cffa                      		rjmp	eeprom_rw1		; Loop while flashing
0000dd 38cd                      		cpi	YL, low(eeprom_end)
0000de f081                      		breq	eeprom_rw4
0000df bb9f                      		out	EEARH, temp2
0000e0 bb8e                      		out	EEARL, temp1
0000e1 9601                      		adiw	temp1, 1
0000e2 9ae0                      		sbi	EECR, EERE		; Read existing EEPROM byte
0000e3 b36d                      		in	temp3, EEDR
0000e4 f017                      		brie	eeprom_rw2
0000e5 9369                      		st	Y+, temp3		; Store the byte to RAM
0000e6 cff0                      		rjmp	eeprom_rw1
0000e7 9179                      eeprom_rw2:	ld	temp4, Y+		; Compare with the byte in RAM
0000e8 bb7d                      		out	EEDR, temp4
0000e9 94f8                      		cli
0000ea 9ae2                      		sbi	EECR, EEMWE
0000eb 1367                      		cpse	temp3, temp4
0000ec 9ae1                      		sbi	EECR, EEWE
0000ed 9478                      		sei
0000ee cfe8                      		rjmp	eeprom_rw1
0000ef dfc2                      eeprom_rw4:	rcall	wait30ms
                                 		; Fall through to set the oscillator calibration
                                 ;-----bko-----------------------------------------------------------------
                                 ; Set the oscillator calibration for 8MHz operation, or set it to 0xff for
                                 ; approximately 16MHz operation even without an external oscillator. This
                                 ; should be safe as long as we restore it during EEPROM accesses. This
                                 ; will have no effect on boards with external oscillators, except that
                                 ; the EEPROM still uses the internal oscillator (at 1MHz).
                                 osccal_set:
                                 .if CPU_MHZ == 16
0000f0 ef8f                      		ldi	temp1, 0xff		; Almost 16MHz
                                 .else
                                 .endif
0000f1 bf81                      		out	OSCCAL, temp1
0000f2 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
                                 ; Shift left temp7:temp6:temp5 temp1 times.
                                 lsl_temp567:
0000f3 0c00                      		lsl	temp5
0000f4 1c11                      		rol	temp6
0000f5 1caa                      		rol	temp7
0000f6 958a                      		dec	temp1
0000f7 f7d9                      		brne	lsl_temp567
0000f8 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
                                 ; Multiply temp1:temp2 by temp3:temp4 and add high 16 bits of result to Y.
                                 ; Clobbers temp5, temp6, and leaves the lower byte in temp7.
                                 mul_y_12x34:
0000f9 9f86                      		mul	temp1, temp3		; Scale raw pulse length to POWER_RANGE: 16x16->32 (bottom 16 discarded)
0000fa 2ca1                      		mov	temp7, temp6		; Save byte 2 of result, discard byte 1 already
0000fb 9f96                      		mul	temp2, temp3
0000fc 0ca0                      		add	temp7, temp5
0000fd 1dc1                      		adc	YL, temp6
0000fe 1fdf                      		adc	YH, ZH
0000ff 9f87                      		mul	temp1, temp4
000100 0ca0                      		add	temp7, temp5
000101 1dc1                      		adc	YL, temp6
000102 1fdf                      		adc	YH, ZH
000103 9f97                      		mul	temp2, temp4
000104 0dc0                      		add	YL, temp5
000105 1dd1                      		adc	YH, temp6		; Product is now in Y, flags set
000106 9508                      		ret
                                 
                                 ;-- Hardware diagnostics -------------------------------------------------
                                 ; Any brushless ESC based on the ATmega8 or similar must tie the sense
                                 ; neutral star to AIN0, and the three sense lines to three ADC pins or
                                 ; two ADC pins and AIN1. All of these pins are also normal I/O pins, so
                                 ; we can drive them and see if the ADC values move. A value that does not
                                 ; move indicates a shorted FET or that an incorrect board target has been
                                 ; flashed.
                                 ;
                                 ; Note: Some FET drivers such as the LM5109 can pull up the output a bit,
                                 ; making the "stuck high" test return a false positive. Perhaps it would
                                 ; be sufficient to test that the phases read as 0 _or_ can be pulled down
                                 ; by driving AIN0 to ground.
                                 ;
                                 ; In typical conditions on the ATmega8, I/O pins transition to low at
                                 ; about 1.42V and to high at about 1.86V. The ADC is 10-bit, however, and
                                 ; should work even with a strong sense voltage divider.
                                 ;
                                 ; Throughout all of this, the motor may be spinning. If so, we should wait
                                 ; long enough that each phase falls to 0V and all tests succeed.
                                 ;
                                 .if CHECK_HARDWARE
                                 		.if defined(mux_a)
                                 		.endif
                                 		.if defined(mux_b)
                                 		.endif
                                 		.if defined(mux_c)
                                 		.endif
                                 		.if !defined(mux_a) || !defined(mux_b) || !defined(mux_c)
                                 		.endif
                                 		.if defined(mux_a)
                                 		.endif
                                 		.if defined(mux_b)
                                 		.endif
                                 		.if defined(mux_c)
                                 		.endif
                                 		.if defined(mux_a)
                                 		.endif
                                 		.if defined(mux_b)
                                 		.endif
                                 		.if defined(mux_c)
                                 		.endif
                                 		.if defined(red_led)
                                 		.elif defined(blue_led)
                                 		.elif defined(green_led)
                                 		.else
                                 		.endif
                                 .endif
                                 
                                 ;-------------------------------------------------------------------------
                                 ; ADC value dumping via the UART. Expects vt100ish.
                                 .if DEBUG_ADC_DUMP
                                 		.if defined(mux_a)
                                 		.endif
                                 		.if defined(mux_b)
                                 		.endif
                                 		.if defined(mux_c)
                                 		.endif
                                 		.if defined(mux_voltage)
                                 		.endif
                                 .endif
                                 
                                 .if DEBUG_TX
                                 .if !defined(txd) && DIR_PD & (1<<1)
                                 .endif
                                 .endif
                                 
                                 ;-- Battery cell count ---------------------------------------------------
                                 ; Assuming a LiPo cell will never exceed 4.3V, we can estimate
                                 ; the number of cells by dividing the measured voltage by 4.3.
                                 .if defined(mux_voltage) && (DEBUG_ADC_DUMP || (!CELL_COUNT && BLIP_CELL_COUNT))
                                 .endif
                                 
                                 .if ADC_READ_NEEDED
                                 .endif
                                 
                                 ;-----bko-----------------------------------------------------------------
                                 ; Unlike the normal evaluate_rc, we look here for programming mode (pulses
                                 ; above PROGRAM_RC_PULS), unless we have received I2C or UART input.
                                 ;
                                 ; With pulse width modulation (PWM) input, we have to be careful about
                                 ; oscillator drift. If we are running on a board without an external
                                 ; crystal/resonator/oscillator, the internal RC oscillator must be used,
                                 ; which can drift significantly with temperature and voltage. So, we must
                                 ; use some margins while calibrating. The internal RC speeds up when cold,
                                 ; causing arming problems if the learned pulse is too low. Likewise, the
                                 ; internal RC slows down when hot, making it impossible to reach full
                                 ; throttle.
                                 evaluate_rc_init:
                                 		.if USE_UART
                                 		.endif
                                 		.if USE_I2C
                                 		.endif
                                 		.if USE_ICP || USE_INT0
000107 7e1f                      		cbr	flags1, (1<<EVAL_RC)
                                 	; Check if pulse is in aliased input range and toggle RCP_ALIAS to match
                                 		.if defined(RCP_ALIAS_SHIFT)
000108 01c3                      		movw	temp1, rx_l		; Atomic copy of rc pulse length
000109 5390                      		sbiwx	temp1, temp2, MIN_RC_PULS * CPU_MHZ
00010a 0b66                      		sbc	temp3, temp3		; All temp3 bits <- carry (set if in aliased range)
00010b 2760                      		eor	temp3, flags0		; XOR against current flags0 value
00010c fd63                      		sbrc	temp3, RCP_ALIAS	; Skip if zero (no change)
00010d c08a                      		rjmp	puls_scale_alias_toggle	; or toggle RCP_ALIAS and rescale
                                 		.endif
                                 		.if RC_CALIBRATION
00010e fd07                      		sbrc	flags0, NO_CALIBRATION	; Is it safe to calibrate now?
00010f c04d                      		rjmp	evaluate_rc_puls
                                 	; If input is above PROGRAM_RC_PULS, we try calibrating throttle
000110 e8c7
000111 e0d0                      		ldi2	YL, YH, puls_high_l	; Start with high pulse calibration
000112 c001                      		rjmp	rc_prog1
000113 df9b                      rc_prog0:	rcall	wait240ms		; Wait for stick movement to settle
                                 	; Collect average of throttle input pulse length
000114 d03f                      rc_prog1:	rcall	rc_prog_get_rx		; Pulse length into temp1:temp2
000115 01bc                      		movw	temp3, temp1		; Save starting pulse length
000116 95a8                      		wdr
000117 9fff                      rc_prog2:	mul	ZH, ZH			; Clear 24-bit result registers (0 * 0 -> temp5:temp6)
000118 24aa                      		clr	temp7
000119 38c7                      		cpi	YL, low(puls_high_l)	; Are we learning the high pulse?
00011a f431                      		brne	rc_prog3		; No, maybe the low pulse
00011b e19f                      		ldi	temp2, 32 * 31/32	; Full speed pulse averaging count (slightly below exact)
00011c 3460
00011d e58b
00011e 0778                      		cpi2	temp3, temp4, PROGRAM_RC_PULS * CPU_MHZ, temp1
00011f f498                      		brcc	rc_prog5		; Equal to or higher than PROGRAM_RC_PULS - start measuring
000120 c03c                      		rjmp	evaluate_rc_puls	; Lower than PROGRAM_RC_PULS - exit programming
000121 9180 0087                 rc_prog3:	lds	temp1, puls_high_l	; If not learning the high pulse, we should stay below it
000123 1768                      		cp	temp3, temp1
000124 9180 0088                 		lds	temp1, puls_high_h
000126 0778                      		cpc	temp4, temp1
                                 rc_prog_brcc_prog1:				; Branch trampoline
000127 f760                      		brcc	rc_prog1		; Restart while pulse not lower than learned high pulse
000128 e292                      		ldi	temp2, 32 * 17/16	; Stop/reverse pulse (slightly above exact)
000129 38c9                      		cpi	YL, low(puls_low_l)	; Are we learning the low pulse?
00012a f041                      		breq	rc_prog5		; Yes, start measuring
00012b 9180 0089                 rc_prog4:	lds	temp1, puls_low_l
00012d 1768                      		cp	temp3, temp1
00012e 9180 008a                 		lds	temp1, puls_low_h
000130 0778                      		cpc	temp4, temp1
000131 f310                      		brcs	rc_prog1		; Restart while pulse lower than learned low pulse
000132 e290                      		ldi	temp2, 32		; Neutral pulse measurement (exact)
000133 2e89                      rc_prog5:	mov	tcnt2h, temp2		; Abuse tcnt2h as pulse counter
000134 95a8                      rc_prog6:	wdr
000135 ff14                      		sbrs	flags1, EVAL_RC		; Wait for next pulse
000136 cffd                      		rjmp	rc_prog6
000137 7e1f                      		cbr	flags1, (1<<EVAL_RC)
000138 d01b                      		rcall	rc_prog_get_rx		; Pulse length into temp1:temp2
000139 0e08                      		add	temp5, temp1		; Accumulate 24-bit average
00013a 1e19                      		adc	temp6, temp2
00013b 1eaf                      		adc	temp7, ZH
00013c 1b86                      		sub	temp1, temp3		; Subtract the starting pulse from this one
00013d 0b97                      		sbc	temp2, temp4		; to find the drift since the starting pulse
                                 	; Check for excessive drift with an emulated signed comparison -
                                 	; add the drift amount to offset the negative side to 0
00013e 5680
00013f 4f9f                      		adiwx	temp1, temp2, MAX_DRIFT_PULS * CPU_MHZ
                                 	; ..then subtract the 2*drift + 1 -- carry will be clear if
                                 	; we drifted outside of the range
000140 5481
000141 4091                      		sbiwx	temp1, temp2, 2 * MAX_DRIFT_PULS * CPU_MHZ + 1
000142 f680                      		brcc	rc_prog0		; Wait and start over if input moved
000143 948a                      		dec	tcnt2h
000144 f779                      		brne	rc_prog6		; Loop until average accumulated
000145 e083                      		ldi	temp1, 3
000146 dfac                      		rcall	lsl_temp567		; Multiply by 8 (so that 32 loops makes average*256)
000147 9219                      		st	Y+, temp6		; Save the top 16 bits as the result
000148 92a9                      		st	Y+, temp7
                                 	; One beep: high (full speed) pulse received
000149 df43                      		rcall	beep_f3
00014a 38c9                      		cpi	YL, low(puls_high_l+2)
00014b f2d9                      		breq	rc_prog_brcc_prog1	; Go back to get low pulse
                                 	; Two beeps: low (stop/reverse) pulse received
00014c df65                      		rcall	wait30ms
00014d df3f                      		rcall	beep_f3
00014e 38cb                      		cpi	YL, low(puls_low_l+2)
                                 		.if RC_PULS_REVERSE
                                 		.else
00014f f011                      		breq	rc_prog_done
                                 		.endif
                                 	; Three beeps: neutral pulse received
000150 df61                      		rcall	wait30ms
000151 df3b                      		rcall	beep_f3
000152 df7c                      rc_prog_done:	rcall	eeprom_write_block
000153 c046                      		rjmp	puls_scale		; Calculate the new scaling factors
                                 rc_prog_get_rx:
000154 01c3                      		movw	temp1, rx_l		; Atomic copy of rc pulse length
                                 		.if defined(RCP_ALIAS_SHIFT)
000155 ff03                      		sbrs	flags0, RCP_ALIAS
000156 9508                      		ret
000157 e0a3                      		ldi	XL, RCP_ALIAS_SHIFT
                                 rc_prog_get_rx1:
000158 0f88                      		lsl	temp1
000159 1f99                      		rol	temp2
00015a 95aa                      		dec	XL
00015b f7e1                      		brne	rc_prog_get_rx1
                                 		.endif
00015c 9508                      		ret
                                 		.endif
                                 		.endif
                                 	; Fall through from evaluate_rc_init
                                 ;-----bko-----------------------------------------------------------------
                                 ; These routines may clobber temp* and Y, but not X.
                                 evaluate_rc:
                                 		.if USE_UART
                                 		.endif
                                 		.if USE_I2C
                                 		.endif
                                 	; Fall through to evaluate_rc_puls
                                 ;-----bko-----------------------------------------------------------------
                                 .if USE_ICP || USE_INT0
                                 evaluate_rc_puls:
00015d 761f                      		cbr	flags1, (1<<EVAL_RC)+(1<<REVERSE)
                                 		.if MOTOR_BRAKE || LOW_BRAKE
                                 		.endif
00015e 01c3                      		movw	temp1, rx_l		; Atomic copy of rc pulse length
00015f 3390                      		cpi2	temp1, temp2, MIN_RC_PULS * CPU_MHZ, temp3
000160 f060                      		brcs	puls_length_short	; Branch if short pulse
                                 		.if defined(RCP_ALIAS)
000161 fd03                      		sbrc	flags0, RCP_ALIAS
000162 c011                      		rjmp	puls_length_error	; Throw away long pulse if alias range expected
                                 		.endif
                                 puls_alias:
                                 		.if LOW_BRAKE
                                 		.endif
000163 91c0 007f                 		lds	YL, neutral_l
000165 91d0 0080                 		lds	YH, neutral_h
000167 1b8c                      		sub	temp1, YL		; Offset input to neutral
000168 0b9d                      		sbc	temp2, YH
000169 f460                      		brcc	puls_plus
                                 		.if RC_PULS_REVERSE
                                 		.endif
                                 		; Fall through to stop/zero in no reverse case
                                 puls_zero_brake:
                                 		.if MOTOR_BRAKE
                                 		.endif
00016a 27cc                      puls_zero:	clr	YL
00016b 27dd                      		clr	YH
00016c c016                      		rjmp	rc_duty_set
                                 puls_length_short:
                                 		.if defined(RCP_ALIAS_SHIFT)
                                 		; Additional length checks for aliased range
00016d 3096                      		cpi2	temp1, temp2, (MIN_RC_PULS * CPU_MHZ) >> RCP_ALIAS_SHIFT, temp3
00016e f028                      		brcs	puls_length_error
00016f 3c80
000170 e162
000171 0796                      		cpi2	temp1, temp2, (MAX_RC_PULS * CPU_MHZ) >> RCP_ALIAS_SHIFT, temp3
000172 fd03                      		sbrc	flags0, RCP_ALIAS	; If alias range expected
000173 f378                      		brcs	puls_alias
                                 		.endif
                                 puls_length_error:
000174 6004                      		sbr	flags0, (1<<RCP_ERROR)
000175 9508                      		ret
                                 puls_plus:
000176 9160 007b                 		lds	temp3, fwd_scale_l	; Load forward scaling factor
000178 9170 007c                 		lds	temp4, fwd_scale_h
                                 puls_not_zero:
                                 		.if RCP_DEADBAND
                                 		.if defined(RCP_ALIAS_SHIFT)
                                 		.else
                                 		.endif
                                 		.endif
                                 .endif
                                 	; The following is used by all input modes
00017a e3c8
00017b e0d0                      rc_do_scale:	ldi2	YL, YH, MIN_DUTY	; Offset result so that 0 is MIN_DUTY
00017c df7c                      		rcall	mul_y_12x34		; Scaled result is now in Y
00017d 35c7
00017e e083
00017f 07d8                      		cpi2	YL, YH, MAX_POWER, temp1
000180 f010                      		brcs	rc_duty_set
000181 e5c7
000182 e0d3                      		ldi2	YL, YH, MAX_POWER
000183 93c0 0079                 rc_duty_set:	sts	rc_duty_l, YL
000185 93d0 007a                 		sts	rc_duty_h, YH
000187 ff01                      		sbrs	flags0, SET_DUTY
000188 c003                      		rjmp	rc_no_set_duty
000189 e082                      		ldi	temp1, RCP_TOT
00018a 2eb8                      		mov	rc_timeout, temp1	; Short rc_timeout when driving
00018b c0a6                      		rjmp	set_new_duty_l		; Skip reload into YL:YH
00018c e08c                      rc_no_set_duty:	ldi	temp1, 12		; More than 10 needed to arm
00018d 16b8                      		cp	rc_timeout, temp1
00018e 1ebf                      		adc	rc_timeout, ZH
00018f 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
                                 .if USE_I2C
                                 .endif
                                 ;-----bko-----------------------------------------------------------------
                                 .if USE_UART
                                 .endif
                                 ;-----bko-----------------------------------------------------------------
                                 ; If an input alias is defined, shift the values in temp3:temp4 and
                                 ; temp1:temp2 to follow.
                                 .if defined(RCP_ALIAS_SHIFT)
                                 puls_scale_alias_shift:
000190 e0c3                      		ldi	YL, RCP_ALIAS_SHIFT
                                 puls_scale_alias_shift1:
000191 9576                      		lsr	temp4
000192 9567                      		ror	temp3
000193 9596                      		lsr	temp2
000194 9587                      		ror	temp1
000195 95ca                      		dec	YL
000196 f7d1                      		brne	puls_scale_alias_shift1
000197 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
                                 ; Toggle RCP_ALIAS and fall through to pulse_scale
                                 puls_scale_alias_toggle:
000198 e088                      		ldi	temp1, (1<<RCP_ALIAS)
000199 2708                      		eor	flags0, temp1
                                 .endif
                                 ;-----bko-----------------------------------------------------------------
                                 ; Calculate the neutral offset and forward (and reverse) scaling factors
                                 ; to line up with the high/low (and neutral) pulse lengths.
                                 puls_scale:
                                 	; If reversible input is enabled, scale from neutral; otherwise,
                                 	; scale from the lowest point.
                                 		.if RC_PULS_REVERSE
                                 		.else
00019a 9180 0089                 		lds	temp1, puls_low_l
00019c 9190 008a                 		lds	temp2, puls_low_h
                                 		.endif
00019e 9160 0087                 		lds	temp3, puls_high_l
0001a0 9170 0088                 		lds	temp4, puls_high_h
                                 		.if defined(RCP_ALIAS_SHIFT)
0001a2 fd03                      		sbrc	flags0, RCP_ALIAS
0001a3 dfec                      		rcall	puls_scale_alias_shift
                                 		.endif
                                 	; Find the distance to full throttle and fit it to match the
                                 	; distance between FULL_RC_PULS and STOP_RC_PULS by walking
                                 	; for the lowest 16.16 multiplier that just brings us in range.
0001a4 9380 007f                 		sts	neutral_l, temp1
0001a6 9390 0080                 		sts	neutral_h, temp2
0001a8 1b68                      		sub	temp3, temp1
0001a9 0b79                      		sbc	temp4, temp2
0001aa d005                      		rcall	puls_find_multiplicand
0001ab 9380 007b                 		sts	fwd_scale_l, temp1
0001ad 9390 007c                 		sts	fwd_scale_h, temp2
                                 
                                 	; If reversible input is enabled, calculate the reverse scaling
                                 	; factor.
                                 		.if RC_PULS_REVERSE
                                 		.if defined(RCP_ALIAS_SHIFT)
                                 		.endif
                                 		.endif
                                 
                                 	; If a deadband is enabled and input aliases are supported,
                                 	; calculate the scaled deadband in advance.
                                 		.if RCP_DEADBAND && defined(RCP_ALIAS_SHIFT)
                                 		.endif
                                 
                                 	; If low brake is enabled, store the position where it starts
                                 	; after subtracting the deadband. This avoids the calculation
                                 	; in the receive path.
                                 		.if LOW_BRAKE
                                 		.if defined(RCP_ALIAS_SHIFT)
                                 		.endif
                                 		.endif
                                 
0001af 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
                                 ; Find the lowest 16.16 multiplicand that brings us to full throttle
                                 ; (POWER_RANGE - MIN_DUTY) when multiplied by temp3:temp4.
                                 ; The range we are looking for is around 3000 - 10000:
                                 ; m = (POWER_RANGE - MIN_DUTY) * 65536 / (1000us * 16MHz)
                                 ; If the input range is < 100us at 8MHz, < 50us at 16MHz, we return
                                 ; too low a multiplicand (higher won't fit in 16 bits).
                                 ; We preload temp1:temp2 with the weakest possible scale based on the
                                 ; fact that we can't accept a wider range than MAX_RC_PULS microseconds.
                                 puls_find_multiplicand:
                                 		.if RCP_DEADBAND
                                 		.endif
0001b0 e585
0001b1 e095                      		ldi2	temp1, temp2, (POWER_RANGE - MIN_DUTY) * 65536 / (MAX_RC_PULS * CPU_MHZ)
0001b2 9601                      puls_find1:	adiw	temp1, 1
0001b3 95a8                      		wdr
0001b4 3f9f                      		cpi	temp2, 0xff
0001b5 0789                      		cpc	temp1, temp2
0001b6 f021                      		breq	puls_find_fail		; Return if we reached 0xffff
                                 	; Start with negative POWER_RANGE so that 0 is full throttle
0001b7 eec0
0001b8 efdc                      		ldi2	YL, YH, MIN_DUTY - POWER_RANGE
0001b9 df3f                      		rcall	mul_y_12x34
                                 	; We will always be increasing the result in steps of less than 1,
                                 	; so we can test for just zero rather than a range.
0001ba f7b9                      		brne	puls_find1
0001bb 9508                      puls_find_fail:	ret
                                 ;-----bko-----------------------------------------------------------------
                                 update_timing:
0001bc 94f8                      		cli
0001bd b58c                      		in	temp1, TCNT1L
0001be b59d                      		in	temp2, TCNT1H
0001bf 9160 0064                 		lds	temp3, tcnt1x
0001c1 b778                      		in	temp4, TIFR
0001c2 9478                      		sei
0001c3 3890                      		cpi	temp2, 0x80		; tcnt1x is right when TCNT1h[7] set;
0001c4 fd72                      		sbrc	temp4, TOV1		; otherwise, if TOV1 is/was pending,
0001c5 1f6f                      		adc	temp3, ZH		; increment our copy of tcnt1x.
                                 
                                 	; Calculate the timing from the last two zero-crossings
0001c6 91c0 0069                 		lds	YL, last_tcnt1_l	; last -> Y
0001c8 91d0 006a                 		lds	YH, last_tcnt1_h
0001ca 90a0 006b                 		lds	temp7, last_tcnt1_x
0001cc 9380 0069                 		sts	last_tcnt1_l, temp1
0001ce 9390 006a                 		sts	last_tcnt1_h, temp2
0001d0 9360 006b                 		sts	last_tcnt1_x, temp3
0001d2 9000 006c                 		lds	temp5, l2_tcnt1_l	; last2 -> temp5
0001d4 9010 006d                 		lds	temp6, l2_tcnt1_h
0001d6 9170 006e                 		lds	temp4, l2_tcnt1_x
0001d8 93c0 006c                 		sts	l2_tcnt1_l, YL
0001da 93d0 006d                 		sts	l2_tcnt1_h, YH
0001dc 92a0 006e                 		sts	l2_tcnt1_x, temp7
                                 
                                 	; Cancel DC bias by starting our timing from the average of the
                                 	; last two zero-crossings. Commutation phases always alternate.
                                 	; Next start = (cur(c) - last2(a)) / 2 + last(b)
                                 	; -> start=(c-b+(c-a)/2)/2+b
                                 	;
                                 	;                  (c - a)
                                 	;         (c - b + -------)
                                 	;                     2
                                 	; start = ----------------- + b
                                 	;                 2
                                 
0001de 1980                      		sub	temp1, temp5		; c' = c - a
0001df 0991                      		sbc	temp2, temp6
0001e0 0b67                      		sbc	temp3, temp4
                                 
                                 	; Limit maximum RPM (fastest timing)
0001e1 3094
0001e2 076f                      		cpi3	temp1, temp2, temp3, TIMING_MAX * CPU_MHZ / 2, temp4
0001e3 f428                      		brcc	update_timing1
0001e4 e080
0001e5 e094
0001e6 e060                      		ldi3	temp1, temp2, temp3, TIMING_MAX * CPU_MHZ / 2
0001e7 94d6                      		lsr	sys_control_h		; limit by reducing power
0001e8 94c7                      		ror	sys_control_l
                                 update_timing1:
                                 
                                 	; Calculate a hopefully sane duty cycle limit from this timing,
                                 	; to prevent excessive current if high duty is requested at low
                                 	; speed. This is the best we can do without a current sensor.
                                 	; The actual current peak will depend on motor KV and voltage,
                                 	; so this is just an approximation. This is calculated smoothly
                                 	; with a (very slow) software divide only if timing permits.
0001e9 3890
0001ea 076f                      		cpi2	temp2, temp3, (TIMING_RANGE3 * CPU_MHZ / 2) >> 8, temp4
0001eb e5a7
0001ec e0b3                      		ldi2	XL, XH, MAX_POWER
0001ed f0f0                      		brcs	update_timing4	; Fast timing: no duty limit.
                                 
                                 		; 24.8-bit fixed-point unsigned divide, inlined with available registers:
                                 		; duty (XL:XH) = MAX_POWER * (TIMING_RANGE3 * CPU_MHZ / 2) / period (temp1:temp2:temp3)
                                 		; This takes about one microsecond per loop, but we only take this path
                                 		; when the motor is spinning slowly.
                                 
0001ee e0a1                      		ldi	XL, byte3(MAX_POWER * (TIMING_RANGE3 * CPU_MHZ / 2) / 0x100)
0001ef e2b1                      		ldi	XH, 33		; Iteration counter
0001f0 017d                      		movw	timing_duty_l, XL
0001f1 e8a0
0001f2 eabb                      		ldi2	XL, XH, MAX_POWER * (TIMING_RANGE3 * CPU_MHZ / 2) / 0x100
                                 
0001f3 9fff                      		mul	ZH, ZH		; Zero temp5, temp6
0001f4 1b77                      		sub	temp4, temp4	; Zero temp4, clear carry
0001f5 c00a                      		rjmp	fudiv24_ep	; Jump with carry clear
                                 fudiv24_loop:
0001f6 1f77                      		rol	temp4
0001f7 1c00                      		rol	temp5
0001f8 1c11                      		rol	temp6
0001f9 1778                      		cp	temp4, temp1	; Divide by commutation period
0001fa 0609                      		cpc	temp5, temp2
0001fb 0616                      		cpc	temp6, temp3
0001fc f018                      		brcs	fudiv24_ep
0001fd 1b78                      		sub	temp4, temp1
0001fe 0a09                      		sbc	temp5, temp2
0001ff 0a16                      		sbc	temp6, temp3
                                 fudiv24_ep:
000200 1faa                      		rol	XL
000201 1fbb                      		rol	XH
000202 1cee                      		rol	timing_duty_l
000203 94fa                      		dec	timing_duty_h
000204 f789                      		brne	fudiv24_loop
000205 95a0                      		com	XL
000206 95b0                      		com	XH
                                 
000207 3da6
000208 07bf                      		cpi2	XL, XH, PWR_MAX_RPM1, temp4
000209 f410                      		brcc	update_timing4
00020a eda6
00020b e0b0                      		ldi2	XL, XH, PWR_MAX_RPM1
00020c 017d                      update_timing4:	movw	timing_duty_l, XL
                                 
00020d 9380 006f                 		sts	timing_l, temp1		; Store timing (120 degrees)
00020f 9390 0070                 		sts	timing_h, temp2
000211 9360 0071                 		sts	timing_x, temp3
                                 
000213 9566                      		lsr	temp3			; c'>>= 1 (shift to 60 degrees)
000214 9597                      		ror	temp2
000215 9587                      		ror	temp1
                                 
                                 .if defined(DC_BIAS_CANCEL)
                                 .else
000216 91c0 0069                 		lds	YL, last_tcnt1_l	; restore original c as a'
000218 91d0 006a                 		lds	YH, last_tcnt1_h
00021a 90a0 006b                 		lds	temp7, last_tcnt1_x
                                 .endif
                                 
00021c e373                      		ldi	temp4, (30 - MOTOR_ADVANCE) * 256 / 60
00021d d03c                      		rcall	update_timing_add_degrees
                                 .if TIMING_OFFSET
                                 .endif
00021e 93c0 0072                 		sts	com_time_l, YL		; Store start of next commutation
000220 93d0 0073                 		sts	com_time_h, YH
000222 92a0 0074                 		sts	com_time_x, temp7
                                 
000224 3190                      		cpi	temp2, 0x10		; Will 240 degrees fit in 15 bits?
000225 076f                      		cpc	temp3, ZH
000226 f018                      		brcs	update_timing_fast
000227 7b2f                      		cbr	flags2, (1<<TIMING_FAST)
000228 d054                      		rcall	set_ocr1a_abs_slow	; Set timer for start of next commutation
000229 c002                      		rjmp	update_timing_out
                                 update_timing_fast:
00022a 6420                      		sbr	flags2, (1<<TIMING_FAST)
00022b d08c                      		rcall	set_ocr1a_abs_fast
                                 update_timing_out:
                                 
00022c fd14                      		sbrc	flags1, EVAL_RC
00022d cf2f                      		rjmp	evaluate_rc		; Set new duty either way
                                 	; Fall through to set_new_duty
                                 ;-----bko-----------------------------------------------------------------
                                 ; Unlike update_timing above, we try not to clobber XL and XH which are
                                 ; used for loop-counting in wait_for_edge.
00022e 91c0 0079                 set_new_duty:	lds	YL, rc_duty_l
000230 91d0 007a                 		lds	YH, rc_duty_h
000232 15ce                      set_new_duty_l:	cp	YL, timing_duty_l
000233 05df                      		cpc	YH, timing_duty_h
000234 f008                      		brcs	set_new_duty10
000235 01e7                      		movw	YL, timing_duty_l	; Limit duty to timing_duty
000236 15cc                      set_new_duty10:	cp	YL, sys_control_l
000237 05dd                      		cpc	YH, sys_control_h
000238 f008                      		brcs	set_new_duty11
000239 01e6                      		movw	YL, sys_control_l	; Limit duty to sys_control
                                 set_new_duty11:
                                 .if SLOW_THROTTLE
                                 .endif
00023a e587
00023b e093                      		ldi2	temp1, temp2, MAX_POWER
00023c 1b8c                      		sub	temp1, YL		; Calculate OFF duty
00023d 0b9d                      		sbc	temp2, YH
00023e f0b1                      		breq	set_new_duty_full
00023f 9620                      		adiw	YL, 0
000240 f0b1                      		breq	set_new_duty_zero
                                 		; Not off and not full power
000241 7f1d                      		cbr	flags1, (1<<FULL_POWER)
000242 6011                      		sbr	flags1, (1<<POWER_ON)
                                 		; At higher PWM frequencies, halve the frequency
                                 		; when starting -- this helps hard drive startup
                                 		.if POWER_RANGE < 1000 * CPU_MHZ / 16
000243 ff16                      		sbrs	flags1, STARTUP
000244 c004                      		rjmp	set_new_duty_set
000245 0f88                      		lsl	temp1
000246 1f99                      		rol	temp2
000247 0fcc                      		lsl	YL
000248 1fdd                      		rol	YH
                                 		.endif
                                 set_new_duty_set:
                                 		; When off duty is short, skip complementary PWM; otherwise,
                                 		; compensate the off_duty time to account for the overhead.
                                 	.if CPWM_SOFT
                                 	.endif
000249 e271                      		ldi	temp4, pwm_on		; Off period < 0x100
00024a 139f                      		cpse	temp2, ZH
00024b e177                      		ldi	temp4, pwm_on_high	; Off period >= 0x100
                                 set_new_duty21:
00024c 95c0                      		com	YL			; Save one's complement of both
00024d 9580                      		com	temp1			; low bytes for up-counting TCNT2
00024e 011e                      		movw	duty_l, YL		; Atomic set new ON duty for PWM interrupt
00024f 94f8                      		cli				; Critical section (off_duty & flags together)
000250 012c                      		movw	off_duty_l, temp1	; Set new OFF duty for PWM interrupt
000251 9370 0065                 		sts	pwm_on_ptr, temp4	; Set Next PWM ON interrupt vector
                                 	.if CPWM_SOFT
                                 	.endif
000253 9478                      		sei
000254 9508                      		ret
                                 set_new_duty_full:
                                 		; Full power
000255 6013                      		sbr	flags1, (1<<FULL_POWER)+(1<<POWER_ON)
000256 cff2                      		rjmp	set_new_duty_set
                                 set_new_duty_zero:
                                 		; Power off
000257 7f1c                      		cbr	flags1, (1<<FULL_POWER)+(1<<POWER_ON)
000258 e27d                      		ldi	temp4, pwm_off		; Skip the on phase entirely
                                 	.if CPWM_SOFT
                                 	.endif
000259 cff2                      		rjmp	set_new_duty21
                                 ;-----bko-----------------------------------------------------------------
                                 ; Multiply the 24-bit timing in temp1:temp2:temp3 by temp4 and add the top
                                 ; 24-bits to YL:YH:temp7.
                                 update_timing_add_degrees:
00025a 9f87                      		mul	temp1, temp4
00025b 0dc1                      		add	YL, temp6		; Discard byte 1 already
00025c 1fdf                      		adc	YH, ZH
00025d 1eaf                      		adc	temp7, ZH
00025e 9f97                      		mul	temp2, temp4
00025f 0dc0                      		add	YL, temp5
000260 1dd1                      		adc	YH, temp6
000261 1eaf                      		adc	temp7, ZH
000262 9f67                      		mul	temp3, temp4
000263 0dd0                      		add	YH, temp5
000264 1ca1                      		adc	temp7, temp6
000265 9508                      		ret
                                 load_timing:
000266 9180 006f                 		lds	temp1, timing_l
000268 9190 0070                 		lds	temp2, timing_h
00026a 9160 0071                 		lds	temp3, timing_x
00026c 91c0 0072                 		lds	YL, com_time_l
00026e 91d0 0073                 		lds	YH, com_time_h
000270 90a0 0074                 		lds	temp7, com_time_x
000272 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
                                 ; Set zero-crossing timeout to 240 degrees
                                 set_ocr1a_zct_slow:
000273 dff2                      		rcall	load_timing
000274 0fc8                      		add	YL, temp1
000275 1fd9                      		adc	YH, temp2
000276 1ea6                      		adc	temp7, temp3
000277 0fc8                      		add	YL, temp1
000278 1fd9                      		adc	YH, temp2
000279 1ea6                      		adc	temp7, temp3
00027a c002                      		rjmp	set_ocr1a_abs_slow
                                 set_timing_degrees_slow:
00027b dfea                      		rcall	load_timing
00027c dfdd                      		rcall	update_timing_add_degrees
                                 	; Fall through to set_ocr1a_abs_slow
                                 ;-----bko-----------------------------------------------------------------
                                 ; Set OCT1_PENDING until the absolute time specified by YL:YH:temp7 passes.
                                 ; Returns current TCNT1(L:H:X) value in temp1:temp2:temp3.
                                 ;
                                 ; tcnt1x may not be updated until many instructions later, even with
                                 ; interrupts enabled, because the AVR always executes one non-interrupt
                                 ; instruction between interrupts, and several other higher-priority
                                 ; interrupts may (have) come up. So, we must save tcnt1x and TIFR with
                                 ; interrupts disabled, then do a correction.
                                 set_ocr1a_abs_slow:
00027d b779                      		in	temp4, TIMSK
00027e 2e07                      		mov	temp5, temp4
00027f 7e7b                      		cbr	temp4, (1<<TOIE1)+(1<<OCIE1A)
000280 bf79                      		out	TIMSK, temp4		; Disable TOIE1 and OCIE1A temporarily
000281 e170                      		ldi	temp4, (1<<OCF1A)
000282 94f8                      		cli
000283 bddb                      		out	OCR1AH, YH
000284 bdca                      		out	OCR1AL, YL
000285 bf78                      		out	TIFR, temp4		; Clear any pending OCF1A interrupt
000286 b58c                      		in	temp1, TCNT1L
000287 b59d                      		in	temp2, TCNT1H
000288 9478                      		sei
000289 6001                      		sbr	flags0, (1<<OCT1_PENDING)
00028a 9160 0064                 		lds	temp3, tcnt1x
00028c b778                      		in	temp4, TIFR
00028d 3890                      		cpi	temp2, 0x80		; tcnt1x is right when TCNT1h[7] set;
00028e fd72                      		sbrc	temp4, TOV1		; otherwise, if TOV1 is/was pending,
00028f 1f6f                      		adc	temp3, ZH		; increment our copy of tcnt1x.
000290 1bc8                      		sub	YL, temp1		; Check that time might have already
000291 0bd9                      		sbc	YH, temp2		; passed -- if so, clear pending flag.
000292 0aa6                      		sbc	temp7, temp3
000293 92a0 0063                 		sts	ocr1ax, temp7
000295 f40a                      		brpl	set_ocr1a_abs_slow1	; Skip set if time has passed
000296 7f0e                      		cbr	flags0, (1<<OCT1_PENDING)
                                 set_ocr1a_abs_slow1:
000297 be09                      		out	TIMSK, temp5		; Enable TOIE1 and OCIE1A again
000298 9508                      		ret
                                 
                                 ; Variants of the above with a fast path when timing is guaranteed to fit
                                 ; within 15 bits.
                                 set_ocr1a_zct:
000299 ff26                      		sbrs	flags2, TIMING_FAST
00029a cfd8                      		rjmp	set_ocr1a_zct_slow
00029b 9180 006f                 		lds	temp1, timing_l
00029d 9190 0070                 		lds	temp2, timing_h
00029f 91c0 0072                 		lds	YL, com_time_l
0002a1 91d0 0073                 		lds	YH, com_time_h
0002a3 0fc8                      		add	YL, temp1
0002a4 1fd9                      		adc	YH, temp2
0002a5 0fc8                      		add	YL, temp1
0002a6 1fd9                      		adc	YH, temp2
0002a7 c010                      		rjmp	set_ocr1a_abs_fast
                                 set_timing_degrees:
0002a8 ff26                      		sbrs	flags2, TIMING_FAST
0002a9 cfd1                      		rjmp	set_timing_degrees_slow
0002aa 9180 006f                 		lds	temp1, timing_l
0002ac 9190 0070                 		lds	temp2, timing_h
0002ae 91c0 0072                 		lds	YL, com_time_l
0002b0 91d0 0073                 		lds	YH, com_time_h
0002b2 9f87                      		mul	temp1, temp4
0002b3 0dc1                      		add	YL, temp6
0002b4 1fdf                      		adc	YH, ZH
0002b5 9f97                      		mul	temp2, temp4
0002b6 0dc0                      		add	YL, temp5
0002b7 1dd1                      		adc	YH, temp6
                                 set_ocr1a_abs_fast:
0002b8 e170                      		ldi	temp4, (1<<OCF1A)
0002b9 94f8                      		cli
0002ba bddb                      		out	OCR1AH, YH
0002bb bdca                      		out	OCR1AL, YL
0002bc bf78                      		out	TIFR, temp4		; Clear any pending OCF1A interrupt
0002bd b58c                      		in	temp1, TCNT1L
0002be b59d                      		in	temp2, TCNT1H
0002bf 6001                      		sbr	flags0, (1<<OCT1_PENDING)
0002c0 93f0 0063                 		sts	ocr1ax, ZH
0002c2 9478                      		sei
0002c3 1bc8                      		sub	YL, temp1		; Check that time might have already
0002c4 0bd9                      		sbc	YH, temp2		; passed -- if so, clear pending flag.
0002c5 f40a                      		brpl	set_ocr1a_abs_fast1	; Skip set if time has passed
0002c6 7f0e                      		cbr	flags0, (1<<OCT1_PENDING)
                                 set_ocr1a_abs_fast1:
0002c7 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
                                 ; Set OCT1_PENDING until the relative time specified by YL:YH:temp7 passes.
0002c8 9627                      set_ocr1a_rel:	adiw	YL, 7			; Compensate for timer increment during in-add-out
0002c9 e170                      		ldi	temp4, (1<<OCF1A)
0002ca 94f8                      		cli
0002cb b58c                      		in	temp1, TCNT1L
0002cc b59d                      		in	temp2, TCNT1H
0002cd 0fc8                      		add	YL, temp1
0002ce 1fd9                      		adc	YH, temp2
0002cf bddb                      		out	OCR1AH, YH
0002d0 bdca                      		out	OCR1AL, YL
0002d1 bf78                      		out	TIFR, temp4		; Clear any pending OCF1A interrupt (7 cycles from TCNT1 read)
0002d2 92a0 0063                 		sts	ocr1ax, temp7
0002d4 6001                      		sbr	flags0, (1<<OCT1_PENDING)
0002d5 9478                      		sei
0002d6 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
0002d7 fd14                      wait_OCT1_tot:	sbrc	flags1, EVAL_RC
0002d8 de84                      		rcall	evaluate_rc
0002d9 fd00                      		sbrc	flags0, OCT1_PENDING
0002da cffc                      		rjmp	wait_OCT1_tot		; Wait for commutation time
0002db 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
                                 switch_power_off:
0002dc bdf5                      		out	TCCR2, ZH		; Disable PWM
0002dd e480                      		ldi	temp1, (1<<TOV2)
0002de bf88                      		out	TIFR, temp1		; Clear pending PWM interrupts
0002df e2eb                      		ldi	ZL, low(pwm_wdr)	; Stop PWM switching
0002e0 b382
0002e1 7c8e
0002e2 bb82                      		all_pFETs_off temp1
0002e3 b382
0002e4 7785
0002e5 bb82                      		all_nFETs_off temp1
                                 		.if MOTOR_BRAKE || LOW_BRAKE
                                 		.endif
0002e6 9508                      		ret
                                 ;-----bko-----------------------------------------------------------------
                                 .if BOOT_JUMP
                                 boot_loader_test:
                                 		.if USE_ICP
                                 		.elif USE_INT0 == 1
0002e7 9b82                      		sbis	PIND, rcp_in		; Skip clear if INT0 pin high
                                 		.else
                                 		.endif
0002e8 93f0 0066                 		sts	rct_boot, ZH		; Clear rct_count when low
0002ea 9180 0066                 		lds	temp1, rct_boot
0002ec ff85                      		sbrs	temp1, 5 		; Wait 32 * 16 * 65536us (~2s) before jumping
0002ed 9508                      boot_ret:	ret
                                 ; Check for boot loader presence
0002ee e0e0                      		ldi	ZL, low(BOOT_START << 1)
0002ef 94f8                      		cli				; Interrupts depend on ZH being 0
0002f0 e1fc                      		ldi	ZH, high(BOOT_START << 1)
0002f1 9185                      		lpm	temp1, Z+
0002f2 9194                      		lpm	temp2, Z
0002f3 e0f0                      		ldi	ZH, 0
0002f4 9478                      		sei
0002f5 9601                      		adiw	temp1, 1		; Check flash contents for 0xffff or 0x0000
0002f6 9702                      		sbiw	temp1, 2
0002f7 f3a8                      		brcs	boot_ret		; Return if boot loader area is empty
                                 boot_loader_jump:
0002f8 94f8                      		cli
0002f9 bbf7                      		out	DDRB, ZH		; Tristate pins
0002fa bbf4                      		out	DDRC, ZH
0002fb bbf1                      		out	DDRD, ZH
0002fc e188
0002fd bd81                      		outi	WDTCR, (1<<WDCE)+(1<<WDE), temp1
0002fe bdf1                      		out	WDTCR, ZH		; Disable watchdog
0002ff 9180 0060                 		lds	temp1, orig_osccal
000301 bf81                      		out	OSCCAL, temp1		; Restore OSCCAL
000302 cafd                      		rjmp	BOOT_START		; Jump to boot loader
                                 .endif
                                 ;-----bko-----------------------------------------------------------------
                                 .if USE_I2C
                                 		.if defined(MK_ADDRESS_PADS)
                                 		.endif
                                 .endif
                                 ;-----bko-----------------------------------------------------------------
                                 .if BEEP_RCP_ERROR
                                 .endif
                                 ;-----bko-----------------------------------------------------------------
                                 main:
000303 2400                      		clr	r0
000304 be0f                      		out	SREG, r0		; Clear interrupts and flags
                                 
                                 	; Set up stack
000305 e5ef
000306 e0f4                      		ldi2	ZL, ZH, RAMEND
000307 bffe                      		out	SPH, ZH
000308 bfed                      		out	SPL, ZL
                                 	; Clear RAM and all registers
000309 9202                      clear_loop:	st	-Z, r0
00030a 36e0                      		cpi	ZL, SRAM_START
00030b 05f0                      		cpc	ZH, r0
00030c f409                      		brne	clear_loop1
00030d e1ee                      		ldi	ZL, 30			; Start clearing registers
00030e 15e0                      clear_loop1:	cp	ZL, r0
00030f 05f0                      		cpc	ZH, r0
000310 f7c1                      		brne	clear_loop		; Leaves with all registers (r0 through ZH) at 0
                                 
                                 	; Save original OSCCAL and reset cause
000311 b781                      		in	temp1, OSCCAL
000312 9380 0060                 		sts	orig_osccal, temp1
000314 b6a4                      		in	temp7, MCUCSR		; Store reset reason in register not used for a while
000315 bff4                      		out	MCUCSR, ZH
                                 
                                 	; Initialize ports
000316 bbf8                      		outi	PORTB, INIT_PB, temp1
000317 bbf7                      		outi	DDRB, DIR_PB | (MOTOR_DEBUG<<3) | (MOTOR_DEBUG<<4) | (MOTOR_DEBUG<<5), temp1
000318 bbf5                      		outi	PORTC, INIT_PC, temp1
000319 bbf4                      		outi	DDRC, DIR_PC, temp1
00031a bbf2                      		outi	PORTD, INIT_PD, temp1
00031b eb8b
00031c bb81                      		outi	DDRD, DIR_PD, temp1
                                 
                                 	; For PWM-enable drivers, set enable after initializing ports
                                 		.if defined(ENABLE_ALL_PORT)
                                 		.endif
                                 		.if defined(ENABLE_A_PORT)
                                 		.endif
                                 		.if defined(ENABLE_B_PORT)
                                 		.endif
                                 		.if defined(ENABLE_C_PORT)
                                 		.endif
                                 
                                 		.if DEBUG_TX
                                 		.endif
                                 
                                 	; Start timers except output PWM
00031d e082
00031e bf83                      		outi	TCCR0, T0CLK, temp1	; timer0: beep control, delays
00031f e081
000320 bd8e                      		outi	TCCR1B, T1CLK, temp1	; timer1: commutation timing, RC pulse measurement
000321 bdf5                      		out	TCCR2, ZH		; timer2: PWM, stopped
                                 
                                 	; Enable watchdog (WDTON may be set or unset)
000322 e188                      		ldi	temp1, (1<<WDCE)+(1<<WDE)
000323 bd81                      		out	WDTCR, temp1
000324 e088                      		ldi	temp1, (1<<WDE)		; Fastest option: ~16.3ms timeout
000325 bd81                      		out	WDTCR, temp1
                                 
                                 	; Wait for power to settle -- this must be no longer than 64ms
                                 	; (with 64ms delayed start fuses) for i2c V2 protocol detection
000326 dd8b                      		rcall	wait30ms		; Running at unadjusted speed(!)
                                 
                                 	; Debugging hooks
                                 		.if DEBUG_ADC_DUMP
                                 		.endif
                                 
                                 	; Read EEPROM block to RAM
000327 dda7                      		rcall	eeprom_read_block	; Also calls osccal_set
000328 dd97                      		rcall	eeprom_check_reset
                                 
                                 	; Early input initialization is required for i2c BL-Ctrl V2 detection
                                 	; This serves data from the EEPROM, so this is as early as possible.
                                 		.if USE_I2C
                                 		.endif
                                 
                                 	; Enable interrupts for early input (i2c)
000329 9478                      		sei
                                 
                                 	; Check hardware (before making any beeps)
                                 		.if CHECK_HARDWARE
                                 		.endif
                                 
                                 	; Check reset cause
00032a faa0                      		bst	temp7, PORF		; Power-on reset
00032b 12af                      		cpse	temp7, ZH		; or zero
00032c f426                      		brtc	init_no_porf
00032d dd51                      		rcall	beep_f1			; Usual startup beeps
00032e dd57                      		rcall	beep_f2
00032f dd5d                      		rcall	beep_f3
000330 c01e                      		rjmp	control_start
                                 init_no_porf:
000331 fea2                      		sbrs	temp7, BORF		; Brown-out reset
000332 c004                      		rjmp	init_no_borf
000333 dd59                      		rcall	beep_f3			; "dead cellphone"
000334 dd4a                      		rcall	beep_f1
000335 6800                      		sbr	flags0, (1<<NO_CALIBRATION)
000336 c018                      		rjmp	control_start
                                 init_no_borf:
000337 fea1                      		sbrs	temp7, EXTRF		; External reset
000338 c002                      		rjmp	init_no_extrf
000339 dd5a                      		rcall	beep_f4			; Single beep
00033a c014                      		rjmp	control_start
                                 init_no_extrf:
00033b 94f8                      		cli				; Disable interrupts for terminal reset causes
                                 
00033c fea3                      		sbrs	temp7, WDRF		; Watchdog reset
00033d c005                      		rjmp	init_no_wdrf
00033e dd40                      init_wdrf1:	rcall	beep_f1			; "siren"
00033f dd3f                      		rcall	beep_f1
000340 dd4c                      		rcall	beep_f3
000341 dd4b                      		rcall	beep_f3
000342 cffb                      		rjmp	init_wdrf1		; Loop forever
                                 init_no_wdrf:
                                 
                                 	; Unknown reset cause: Beep out all 8 bits
                                 	; Sometimes I can cause this by touching the oscillator.
000343 dd6b                      init_bitbeep1:	rcall	wait240ms
000344 2d4a                      		mov	i_temp1, temp7
000345 e058                      		ldi	i_temp2, 8
000346 ff40                      init_bitbeep2:	sbrs	i_temp1, 0
000347 dd3e                      		rcall	beep_f2
000348 fd40                      		sbrc	i_temp1, 0
000349 dd4a                      		rcall	beep_f4
00034a dd65                      		rcall	wait120ms
00034b 9546                      		lsr	i_temp1
00034c 955a                      		dec	i_temp2
00034d f7c1                      		brne	init_bitbeep2
00034e cff4                      		rjmp	init_bitbeep1		; Loop forever
                                 
                                 control_start:
                                 
                                 ; Check cell count
                                 .if BLIP_CELL_COUNT
                                 	.if defined(mux_voltage) && !CELL_COUNT
                                 	.else
                                 	.endif
                                 .endif
                                 
                                 control_disarm:
                                 	; LEDs off while disarmed
                                 		BLUE_off
                                 		GRN_off
                                 		RED_off
                                 
00034f 7f0d                      		cbr	flags0, (1<<SET_DUTY)	; We need to count a full rc_timeout for safe arming
000350 de49                      		rcall	puls_scale
                                 
                                 	; Enable timer interrupts (we only do this late to improve beep quality)
000351 e584                      		ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE2)
000352 bf88                      		out	TIFR, temp1		; Clear TOIE1, OCIE1A, and TOIE2 flags
000353 bf89                      		out	TIMSK, temp1		; Enable t1ovfl_int, t1oca_int, t2ovfl_int
                                 
                                 		.if defined(HK_PROGRAM_CARD)
                                 		.endif
                                 
                                 	; Initialize input sources (i2c and/or rc-puls)
                                 		.if USE_UART && !defined(HK_PROGRAM_CARD)
                                 		.endif
                                 		.if USE_I2C
                                 		.endif
                                 		.if USE_INT0 || USE_ICP
000354 e083
000355 bf85                      		rcp_int_rising_edge temp1
000356 e480
000357 bf8b                      		rcp_int_enable temp1
                                 		.endif
                                 
                                 	; Wait for one of the input sources to give arming input
                                 
000358 24bb                      i_rc_puls1:	clr	rc_timeout
000359 7e13                      		cbr	flags1, (1<<EVAL_RC)+(1<<I2C_MODE)+(1<<UART_MODE)
00035a 93f0 0066                 		sts	rct_boot, ZH
00035c 93f0 0067                 		sts	rct_beacon, ZH
00035e 95a8                      i_rc_puls2:	wdr
                                 		.if defined(HK_PROGRAM_CARD)
                                 		.endif
00035f fd14                      		sbrc	flags1, EVAL_RC
000360 c00a                      		rjmp	i_rc_puls_rx
                                 		.if BOOT_JUMP
000361 df85                      		rcall	boot_loader_test
                                 		.endif
                                 		.if BEACON
000362 9180 0067                 		lds	temp1, rct_beacon
000364 3788                      		cpi	temp1, 120		; Beep every 120 * 16 * 65536us (~8s)
000365 f7c1                      		brne	i_rc_puls2
000366 e38c                      		ldi	temp1, 60
000367 9380 0067                 		sts	rct_beacon, temp1	; Double rate after the first beep
000369 dd23                      		rcall	beep_f3			; Beacon
                                 		.endif
00036a cff3                      		rjmp	i_rc_puls2
00036b dd9b                      i_rc_puls_rx:	rcall	evaluate_rc_init
00036c 91c0 0079                 		lds	YL, rc_duty_l
00036e 91d0 007a                 		lds	YH, rc_duty_h
000370 9620                      		adiw	YL, 0			; Test for zero
000371 f731                      		brne	i_rc_puls1
000372 e08a                      		ldi	temp1, 10		; wait for this count of receiving power off
000373 16b8                      		cp	rc_timeout, temp1
000374 f348                      		brlo	i_rc_puls2
                                 		.if USE_I2C
                                 		.endif
                                 		.if USE_UART
                                 		.endif
                                 		.if USE_INT0 || USE_ICP
000375 2f81                      		mov	temp1, flags1
000376 708c                      		andi	temp1, (1<<I2C_MODE)+(1<<UART_MODE)
000377 f009                      		breq	i_rc_puls3
000378 bffb                      		rcp_int_disable temp1		; Turn off RC pulse interrupt
                                 i_rc_puls3:
                                 		.endif
                                 
000379 dd1a                      		rcall	beep_f4			; signal: rcpuls ready
00037a dd19                      		rcall	beep_f4
00037b dd18                      		rcall	beep_f4
00037c 7f0b                      		cbr     flags0, (1<<RCP_ERROR)
                                 
                                 	; Fall through to restart_control
                                 ;-----bko-----------------------------------------------------------------
                                 restart_control:
00037d df5e                      		rcall	switch_power_off	; Disables PWM timer, turns off all FETs
00037e 7f0d                      		cbr	flags0, (1<<SET_DUTY)	; Do not yet set duty on input
                                 		.if BEACON_IDLE
                                 		.endif
                                 		GRN_on				; Green on while armed and idle or braking
                                 		RED_off
                                 		BLUE_off
                                 wait_for_power_on_init:
00037f 93f0 0066                 		sts	rct_boot, ZH
000381 93f0 0067                 		sts	rct_beacon, ZH
                                 
                                 		.if MOTOR_BRAKE || LOW_BRAKE
                                 		.endif
                                 
                                 wait_for_power_on:
000383 95a8                      		wdr
000384 fd14                      		sbrc	flags1, EVAL_RC
000385 c00c                      		rjmp	wait_for_power_rx
                                 		.if BEEP_RCP_ERROR
                                 		.endif
                                 		.if BEACON_IDLE
                                 		.endif
000386 20bb                      		tst	rc_timeout
000387 f7d9                      		brne	wait_for_power_on	; Tight loop unless rc_timeout is zero
                                 		.if BOOT_JUMP
000388 df5e                      		rcall	boot_loader_test
                                 		.endif
000389 9180 0067                 		lds	temp1, rct_beacon
00038b 318e                      		cpi	temp1, 30		; Disarm after ~2 seconds of no signal
00038c f7b1                      		brne	wait_for_power_on
00038d df4e                      		rcall	switch_power_off	; Brake may have been on
00038e dd23                      		rcall	wait30ms
00038f dcfd                      		rcall	beep_f3			; Play beeps for signal lost, disarming
000390 dcf5                      		rcall	beep_f2
000391 cfbd                      		rjmp	control_disarm		; Do not start motor until neutral signal received once again
                                 
                                 wait_for_power_rx:
                                 		.if USE_I2C
                                 		.endif
000392 ddca                      		rcall	evaluate_rc		; Only get rc_duty, don't set duty
000393 20bb                      		tst	rc_timeout		; If not a valid signal, loop
000394 f371                      		breq	wait_for_power_on	; while increasing boot/beacon timers
000395 9620                      		adiw	YL, 0			; If no power requested yet, loop
000396 f341                      		breq	wait_for_power_on_init	; while resetting boot/beacon timers
                                 
                                 start_from_running:
000397 df44                      		rcall	switch_power_off
000398 b780
000399 6088
00039a bf80
00039b 9837                      		comp_init temp1			; init comparator
                                 		RED_off
                                 		GRN_off
                                 		BLUE_on
                                 
00039c e8ce
00039d e0d0                      		ldi2	YL, YH, PWR_MIN_START	; Start with limited power to reduce the chance that we
00039e 016e                      		movw	sys_control_l, YL	; align to a timing harmonic
                                 
00039f 6002                      		sbr	flags0, (1<<SET_DUTY)
                                 		; Set STARTUP flag and call update_timing which will set
                                 		; last_tcnt1 and set the duty (limited by STARTUP) and
                                 		; set POWER_ON.
0003a0 d0d6                      		rcall	wait_timeout_init
0003a1 93f0 0075                 		sts	start_delay, ZH
0003a3 93f0 0076                 		sts	start_modulate, ZH
0003a5 93f0 0077                 		sts	start_fail, ZH
0003a7 e082                      		ldi	temp1, RCP_TOT		; Start with a short timeout to stop quickly
0003a8 2eb8                      		mov	rc_timeout, temp1	; if we see no further pulses after the first.
0003a9 e086                      		ldi	temp1, 6		; Do not enable FETs during first cycle to
0003aa 9380 0062                 		sts	powerskip, temp1	; see if motor is running, and align to it.
0003ac e08c                      		ldi	temp1, ENOUGH_GOODIES	; If we can follow without a timeout, do not
0003ad 9380 0061                 		sts	goodies, temp1		; continue in startup mode (long ZC filtering).
0003af e081
0003b0 bd85                      		outi	TCCR2, T2CLK, temp1	; Enable PWM (ZL has been set to pwm_wdr)
                                 
                                 ;-----bko-----------------------------------------------------------------
                                 ; *** commutation utilities ***
                                 
                                 .macro com1com2
                                 		; Bp off, Ap on
                                 		set_comp_phase_b temp1
                                 		COMMUTATE_B_off
                                 		sbrc	flags1, POWER_ON
                                 		COMMUTATE_A_on
                                 .endmacro
                                 
                                 .macro com2com1
                                 		; Bp on, Ap off
                                 		set_comp_phase_a temp1
                                 		COMMUTATE_A_off
                                 		sbrc	flags1, POWER_ON
                                 		COMMUTATE_B_on
                                 .endmacro
                                 
                                 .macro com2com3
                                 		; Cn off, Bn on
                                 		set_comp_phase_c temp1
                                 		cli
                                 		cbr	flags2, ALL_FETS
                                 		sbr	flags2, (1<<B_FET)
                                 		PWM_FOCUS_C_off
                                 		PWM_C_clear
                                 		PWM_B_copy
                                 		PWM_FOCUS_B_on
                                 		sei
                                 .endmacro
                                 
                                 .macro com3com2
                                 		; Cn on, Bn off
                                 		set_comp_phase_b temp1
                                 		cli
                                 		cbr	flags2, ALL_FETS
                                 		sbr	flags2, (1<<C_FET)
                                 		PWM_FOCUS_B_off
                                 		PWM_B_clear
                                 		PWM_C_copy
                                 		PWM_FOCUS_C_on
                                 		sei
                                 .endmacro
                                 
                                 .macro com3com4
                                 		; Ap off, Cp on
                                 		set_comp_phase_a temp1
                                 		COMMUTATE_A_off
                                 		sbrc	flags1, POWER_ON
                                 		COMMUTATE_C_on
                                 .endmacro
                                 
                                 .macro com4com3
                                 		; Ap on, Cp off
                                 		set_comp_phase_c temp1
                                 		COMMUTATE_C_off
                                 		sbrc	flags1, POWER_ON
                                 		COMMUTATE_A_on
                                 .endmacro
                                 
                                 .macro com4com5
                                 		; Bn off, An on
                                 		set_comp_phase_b temp1
                                 		cli
                                 		cbr	flags2, ALL_FETS
                                 		sbr	flags2, (1<<A_FET)
                                 		PWM_FOCUS_B_off
                                 		PWM_B_clear
                                 		PWM_A_copy
                                 		PWM_FOCUS_A_on
                                 		sei
                                 .endmacro
                                 
                                 .macro com5com4
                                 		; Bn on, An off
                                 		set_comp_phase_a temp1
                                 		cli
                                 		cbr	flags2, ALL_FETS
                                 		sbr	flags2, (1<<B_FET)
                                 		PWM_FOCUS_A_off
                                 		PWM_A_clear
                                 		PWM_B_copy
                                 		PWM_FOCUS_B_on
                                 		sei
                                 .endmacro
                                 
                                 .macro com5com6
                                 		; Cp off, Bp on
                                 		set_comp_phase_c temp1
                                 		COMMUTATE_C_off
                                 		sbrc	flags1, POWER_ON
                                 		COMMUTATE_B_on
                                 .endmacro
                                 
                                 .macro com6com5
                                 		; Cp on, Bp off
                                 		set_comp_phase_b temp1
                                 		COMMUTATE_B_off
                                 		sbrc	flags1, POWER_ON
                                 		COMMUTATE_C_on
                                 .endmacro
                                 
                                 .macro com6com1
                                 		; An off, Cn on
                                 		set_comp_phase_a temp1
                                 		cli
                                 		cbr	flags2, ALL_FETS
                                 		sbr	flags2, (1<<C_FET)
                                 		PWM_FOCUS_A_off
                                 		PWM_A_clear
                                 		PWM_C_copy
                                 		PWM_FOCUS_C_on
                                 		sei
                                 .endmacro
                                 
                                 .macro com1com6
                                 		; An on, Cn off
                                 		set_comp_phase_c temp1
                                 		cli
                                 		cbr	flags2, ALL_FETS
                                 		sbr	flags2, (1<<A_FET)
                                 		PWM_FOCUS_C_off
                                 		PWM_C_clear
                                 		PWM_A_copy
                                 		PWM_FOCUS_A_on
                                 		sei
                                 .endmacro
                                 
                                 ;-----bko-----------------------------------------------------------------
                                 ; **** running control loop ****
                                 
                                 run1:		.if MOTOR_REVERSE
                                 		.else
0003b1 fd17                      		sbrc	flags1, REVERSE
                                 		.endif
0003b2 c037                      		rjmp	run_reverse
                                 
                                 run_forward:
0003b3 d0c7                      		rcall	wait_for_high
0003b4 e083
0003b5 b987
0003b6 9894
0003b7 fd10
0003b8 9a90                      		com1com2
                                 		sync_off
0003b9 d0bf                      		rcall	wait_for_low
0003ba e084
0003bb b987
0003bc 94f8
0003bd 7f28
0003be 6022
0003bf b382
0003c0 9897
0003c1 b392
0003c2 1389
0003c3 9a93
0003c4 9478                      		com2com3
0003c5 d0b5                      		rcall	wait_for_high
0003c6 e082
0003c7 b987
0003c8 9890
0003c9 fd10
0003ca 9a95                      		com3com4
0003cb d0ad                      		rcall	wait_for_low
0003cc e083
0003cd b987
0003ce 94f8
0003cf 7f28
0003d0 6021
0003d1 b382
0003d2 9893
0003d3 b392
0003d4 1389
0003d5 9a91
0003d6 9478                      		com4com5
                                 		sync_on
0003d7 d0a3                      		rcall	wait_for_high
0003d8 e084
0003d9 b987
0003da 9895
0003db fd10
0003dc 9a94                      		com5com6
0003dd d09b                      		rcall	wait_for_low
0003de e082
0003df b987
0003e0 94f8
0003e1 7f28
0003e2 6024
0003e3 b382
0003e4 9891
0003e5 b392
0003e6 1389
0003e7 9a97
0003e8 9478                      		com6com1
0003e9 c036                      		rjmp	run6
                                 
                                 run_reverse:
0003ea d08e                      		rcall	wait_for_low
0003eb e084
0003ec b987
0003ed 94f8
0003ee 7f28
0003ef 6021
0003f0 b382
0003f1 9897
0003f2 b392
0003f3 1389
0003f4 9a91
0003f5 9478                      		com1com6
                                 		sync_on
0003f6 d084                      		rcall	wait_for_high
0003f7 e083
0003f8 b987
0003f9 9894
0003fa fd10
0003fb 9a95                      		com6com5
0003fc d07c                      		rcall	wait_for_low
0003fd e082
0003fe b987
0003ff 94f8
000400 7f28
000401 6022
000402 b382
000403 9891
000404 b392
000405 1389
000406 9a93
000407 9478                      		com5com4
000408 d072                      		rcall	wait_for_high
000409 e084
00040a b987
00040b 9895
00040c fd10
00040d 9a90                      		com4com3
                                 		sync_off
00040e d06a                      		rcall	wait_for_low
00040f e083
000410 b987
000411 94f8
000412 7f28
000413 6024
000414 b382
000415 9893
000416 b392
000417 1389
000418 9a97
000419 9478                      		com3com2
00041a d060                      		rcall	wait_for_high
00041b e082
00041c b987
00041d 9890
00041e fd10
00041f 9a94                      		com2com1
                                 
                                 run6:
                                 		.if MOTOR_BRAKE || LOW_BRAKE
                                 		.endif
000420 9180 0061                 		lds	temp1, goodies
                                 		.if !MOTOR_BRAKE
                                 		; If last commutation timed out and power is off, return to restart_control
000422 3080                      		cpi	temp1, 0
000423 ff10                      		sbrs	flags1, POWER_ON
000424 f169                      		breq	run_to_brake
                                 		.endif
000425 01e6                      		movw	YL, sys_control_l	; Each time TIMING_MAX is hit, sys_control is lsr'd
000426 9620                      		adiw	YL, 0			; If zero, try starting over (with powerskipping)
000427 f159                      		breq	restart_run
000428 308c                      		cpi	temp1, ENOUGH_GOODIES
000429 f4c8                      		brcc	run6_2
00042a 9583                      		inc	temp1
00042b 9380 0061                 		sts	goodies, temp1
                                 		; Build up sys_control to PWR_MAX_START in steps.
00042d 9662                      		adiwx	YL, YH, (POWER_RANGE + 47) / 48
00042e ed86
00042f e090                      		ldi2	temp1, temp2, PWR_MAX_START
                                 		; If we've been trying to start for a while,
                                 		; modulate power to reduce heating.
000430 9160 0077                 		lds	temp3, start_fail
000432 9170 0076                 		lds	temp4, start_modulate
000434 5f7c                      		subi	temp4, -START_MOD_INC
000435 9370 0076                 		sts	start_modulate, temp4
000437 f421                      		brne	run6_1
                                 		; If we've been trying for a long while, give up.
000438 5f60                      		subi	temp3, -START_FAIL_INC
000439 f0d1                      		breq	start_failed
00043a 9360 0077                 		sts	start_fail, temp3
                                 run6_1:		; Allow first loop at full power, then modulate.
00043c 3160                      		cpi	temp3, START_FAIL_INC
00043d f068                      		brcs	run6_3
00043e 3370                      		cpi	temp4, START_MOD_LIMIT
00043f f058                      		brcs	run6_3
000440 e283
000441 e090                      		ldi2	temp1, temp2, PWR_COOL_START
000442 c008                      		rjmp	run6_3
                                 
                                 run6_2:
000443 7b1f                      		cbr	flags1, (1<<STARTUP)
000444 93f0 0077                 		sts	start_fail, ZH
000446 93f0 0076                 		sts	start_modulate, ZH
                                 		RED_off
                                 		; Build up sys_control to MAX_POWER in steps.
                                 		; If SLOW_THROTTLE is disabled, this only limits
                                 		; initial start ramp-up; once running, sys_control
                                 		; will stay at MAX_POWER unless timing is lost.
000448 966b                      		adiwx	YL, YH, (POWER_RANGE + 31) / 32
000449 e587
00044a e093                      		ldi2	temp1, temp2, MAX_POWER
00044b 17c8                      run6_3:		cp	YL, temp1
00044c 07d9                      		cpc	YH, temp2
00044d f010                      		brcs	run6_4
00044e 016c                      		movw	sys_control_l, temp1
00044f cf61                      		rjmp	run1
000450 016e                      run6_4:		movw	sys_control_l, YL
000451 cf5f                      		rjmp	run1
                                 
000452 cf2a                      run_to_brake:	rjmp	restart_control
000453 cf43                      restart_run:	rjmp	start_from_running
                                 
                                 ;-----bko-----------------------------------------------------------------
                                 ; If we were unable to start for a long time, just sit and beep unless
                                 ; input goes back to no power. This might help us get found if crashed.
                                 start_failed:
000454 de87                      		rcall	switch_power_off
000455 7f0d                      		cbr	flags0, (1<<SET_DUTY)
                                 start_fail_beep:
000456 dc58                      		rcall	wait240ms
000457 dc57                      		rcall	wait240ms
000458 dc3b                      		rcall	beep_f4			; "Start failed" beacon
000459 dd03                      		rcall	evaluate_rc		; Returns rc_duty when !SET_DUTY
00045a 9620                      		adiw	YL, 0			; Test for zero
00045b f7d1                      		brne	start_fail_beep
00045c cef2                      		rjmp	control_disarm
                                 
                                 ;-----bko-----------------------------------------------------------------
                                 demag_timeout:
00045d e2eb                      		ldi	ZL, low(pwm_wdr)	; Stop PWM switching
                                 		; Interrupts will not turn on any FETs now
                                 		.if COMP_PWM && CPWM_SOFT
                                 		.elif COMP_PWM && !CPWM_SOFT
                                 		.endif
00045e b382
00045f 7785
000460 bb82                      		PWM_ALL_off temp1
                                 		RED_on
                                 		; Skip power for the next commutation. Note that this
                                 		; won't decrease a non-zero powerskip because demag
                                 		; checking is skipped when powerskip is non-zero.
000461 e081                      		ldi	temp1, 1
000462 9380 0062                 		sts	powerskip, temp1
000464 c05c                      		rjmp	wait_commutation
                                 ;-----bko-----------------------------------------------------------------
                                 wait_timeout:
000465 fd16                      		sbrc	flags1, STARTUP
000466 c008                      		rjmp	wait_timeout_start
000467 30bc                      		cpi	XH, ZC_CHECK_FAST
000468 f030                      		brcs	wait_timeout_run
000469 e0bb                      		ldi	XH, ZC_CHECK_FAST - 1	; Limit back-tracking
00046a 17ab                      		cp	XL, XH
00046b f408                      		brcc	wait_timeout1
00046c 2fab                      		mov	XL, XH			; Clip current distance from crossing
00046d de2b                      wait_timeout1:	rcall	set_ocr1a_zct		; Set zero-crossing timeout
00046e c045                      		rjmp	wait_for_edge2
                                 wait_timeout_run:
                                 		RED_on				; Turn on red LED
                                 wait_timeout_start:
00046f 93f0 0061                 		sts	goodies, ZH		; Clear good commutation count
000471 9170 0075                 		lds	temp4, start_delay
000473 5f71                      		subi	temp4, -START_DELAY_INC	; Increase start (blanking) delay,
000474 fd16                      		sbrc	flags1, STARTUP		; unless we were running
000475 9370 0075                 		sts	start_delay, temp4
                                 wait_timeout_init:
000477 6410                      		sbr	flags1, (1<<STARTUP)	; Leave running mode
000478 c048                      		rjmp	wait_commutation	; Update timing and duty.
                                 ;-----bko-----------------------------------------------------------------
000479 7d1f                      wait_for_low:	cbr	flags1, (1<<ACO_EDGE_HIGH)
00047a c001                      		rjmp	wait_for_edge
                                 ;-----bko-----------------------------------------------------------------
00047b 6210                      wait_for_high:	sbr	flags1, (1<<ACO_EDGE_HIGH)
                                 ;-----bko-----------------------------------------------------------------
                                 ; Here we wait for the zero-crossing on the undriven phase to synchronize
                                 ; with the motor timing. The voltage of the undriven phase should cross
                                 ; the average of all three phases at half of the way into the 60-degree
                                 ; commutation period.
                                 ;
                                 ; The voltage on the undriven phase is affected by noise from PWM (mutual
                                 ; inductance) and also the demagnetization from the previous commutation
                                 ; step. Demagnetization time is proportional to motor current, and in
                                 ; extreme cases, may take more than 30 degrees to complete. To avoid
                                 ; sensing erroneous early zero-crossings in this case and losing motor
                                 ; synchronization, we check that demagnetization has finished after the
                                 ; minimum blanking period. If we do not see it by the maximum blanking
                                 ; period (about 30 degrees since we commutated last), we turn off power
                                 ; and continue as if the ZC had occurred. PWM is enabled again after the
                                 ; next commutation step.
                                 ;
                                 ; Normally, we wait for the blanking window to pass, look for the
                                 ; comparator to swing as the sign of the zero crossing, wait for the
                                 ; timing delay, and then commutate.
                                 ;
                                 ; Simulations show that the demagnetization period shows up on the phase
                                 ; being monitored by the comparator with no PWM-induced noise. As such,
                                 ; we do not need any filtering. However, it may not show up immediately
                                 ; due to filtering capacitors, hence the initial blind minimum blanking
                                 ; period.
                                 ;
                                 ; Special case: powerskipping during start. The idea here is to learn the
                                 ; timing of a possibly-spinning motor while not driving it, which would
                                 ; induce demagnetization and PWM noise that we cannot ignore until we
                                 ; know the timing. We use twice the timeout that would otherwise bring
                                 ; ZC check count to 0xff. A motor spinning twice the speed or slower will
                                 ; fall through to regular startup with ZC check count at 0xff. This lets
                                 ; us start from braking, RC timeout, or power-up without misaligning.
                                 ;
                                 wait_for_edge:
00047c 9180 0062                 		lds	temp1, powerskip	; Are we trying to track a maybe running motor?
00047e 5081                      		subi	temp1, 1
00047f f050                      		brcs	wait_pwm_enable
000480 9380 0062                 		sts	powerskip, temp1
000482 ff16                      		sbrs	flags1, STARTUP
000483 c018                      		rjmp	wait_for_edge0
000484 e0c0                      		ldi	YL, byte1(0xff * 0x100)	; Timing is 120 degrees, so wait for
000485 efdf                      		ldi	YH, byte2(0xff * 0x100)	; what would be 0xff at 60 degrees
000486 2eaf                      		mov	temp7, ZH
000487 de40                      		rcall	set_ocr1a_rel
000488 e0a3                      		ldi	XL, ZC_CHECK_MIN	; There shouldn't be much noise with no power
000489 c029                      		rjmp	wait_for_edge1
                                 wait_pwm_enable:
00048a 32eb                      		cpi	ZL, low(pwm_wdr)
00048b f409                      		brne	wait_pwm_running
00048c e2ed                      		ldi	ZL, low(pwm_off)	; Re-enable PWM if disabled for powerskip or sync loss avoidance
                                 		RED_off				; wait_timeout would have happened if motor not spinning during powerskip
                                 wait_pwm_running:
00048d fd16                      		sbrc	flags1, STARTUP
00048e c03e                      		rjmp	wait_startup
00048f e17b                      		ldi	temp4, 13 * 256 / 120
000490 de17                      		rcall	set_timing_degrees
000491 de45                      		rcall	wait_OCT1_tot		; Wait for the minimum blanking period
                                 
000492 e579                      		ldi	temp4, 42 * 256 / 120
000493 de14                      		rcall	set_timing_degrees	; Set timeout for maximum blanking period
                                 wait_for_demag:
000494 ff00                      		sbrs	flags0, OCT1_PENDING
000495 cfc7                      		rjmp	demag_timeout
000496 fd14                      		sbrc	flags1, EVAL_RC
000497 dcc5                      		rcall	evaluate_rc
000498 b168                      		in	temp3, ACSR
000499 2761                      		eor	temp3, flags1
                                 		.if HIGH_SIDE_PWM
                                 		.else
00049a fd65                      		sbrc	temp3, ACO		; Check for opposite level (demagnetization)
                                 		.endif
00049b cff8                      		rjmp	wait_for_demag
                                 wait_for_edge0:
00049c 91a0 0070                 		lds	XL, timing_h		; Copy high and extended byte
00049e 91b0 0071                 		lds	XH, timing_x		; to calculate the ZC check count
0004a0 95b6                      		lsr	XH			; Quarter to obtain timing / 1024
0004a1 95a7                      		ror	XL
0004a2 95b6                      		lsr	XH
0004a3 95a7                      		ror	XL
0004a4 30a3                      		cpi	XL, ZC_CHECK_MIN
0004a5 07bf                      		cpc	XH, ZH
0004a6 f050                      		brcs	wait_for_edge_fast_min
0004a7 f051                      		breq	wait_for_edge_fast
                                 .if ZC_CHECK_MAX < 256
0004a8 31aa                      		cpi	XL, ZC_CHECK_MAX
                                 .else
                                 .endif
0004a9 07bf                      		cpc	XH, ZH
0004aa f008                      		brcs	wait_for_edge_below_max
0004ab e1aa                      		ldi	XL, ZC_CHECK_MAX	; Limit to ZC_CHECK_MAX
                                 wait_for_edge_below_max:
0004ac 30ac                      		cpi	XL, ZC_CHECK_FAST	; For faster timing, set normal ZC timeout
0004ad f020                      		brcs	wait_for_edge_fast
0004ae e373                      		ldi	temp4, 24 * 256 / 120	; With slower (longer) timing, set timer
0004af ddf8                      		rcall	set_timing_degrees	; for limited backtracing
0004b0 c002                      		rjmp	wait_for_edge1
                                 wait_for_edge_fast_min:
0004b1 e0a3                      		ldi	XL, ZC_CHECK_MIN
                                 wait_for_edge_fast:
0004b2 dde6                      		rcall	set_ocr1a_zct		; Set zero-crossing timeout
                                 
0004b3 2fba                      wait_for_edge1:	mov	XH, XL
0004b4 ff00                      wait_for_edge2:	sbrs	flags0, OCT1_PENDING
0004b5 cfaf                      		rjmp	wait_timeout
0004b6 fd14                      		sbrc	flags1, EVAL_RC
0004b7 dca5                      		rcall	evaluate_rc
0004b8 b168                      		in	temp3, ACSR
                                 .if 0
                                 .endif
0004b9 2761                      		eor	temp3, flags1
                                 		.if HIGH_SIDE_PWM
                                 		.else
0004ba fd65                      		sbrc	temp3, ACO
                                 		.endif
0004bb c003                      		rjmp	wait_for_edge3
0004bc 17ab                      		cp	XL, XH			; Not yet crossed
0004bd 1faf                      		adc	XL, ZH			; Increment if not at zc_filter
0004be cff5                      		rjmp	wait_for_edge2
0004bf 95aa                      wait_for_edge3:	dec	XL			; Zero-cross has happened
0004c0 f799                      		brne	wait_for_edge2		; Check again unless temp1 is zero
                                 
                                 wait_commutation:
                                 		flag_on
0004c1 dcfa                      		rcall	update_timing
0004c2 ff16                      		sbrs	flags1, STARTUP
0004c3 de13                      		rcall	wait_OCT1_tot
                                 		flag_off
0004c4 9180 0062                 		lds	temp1, powerskip
0004c6 138f                      		cpse	temp1, ZH
0004c7 7f1e                      		cbr	flags1, (1<<POWER_ON)	; Disable power when powerskipping
0004c8 12bf                      		cpse	rc_timeout, ZH
0004c9 9508                      		ret
0004ca 918f                      		pop	temp1			; Throw away return address
0004cb 918f                      		pop	temp1
0004cc ceb0                      		rjmp	restart_control		; Restart control immediately on RC timeout
                                 
                                 ; When starting, we have no idea what sort of motor may be connected,
                                 ; or how much time it will take for the previous commutation current
                                 ; to stop flowing. If the motor is not spinning and the sensing while
                                 ; powerskipping fails, we apply power and check for back-EMF after an
                                 ; increasing delay, building up further if the motor remains stalled.
                                 ; This will stretch out short commutations caused by the comparator
                                 ; sitting low or high when inputs are below the minimum offset.
                                 wait_startup:
0004cd e0c0
0004ce e0d0
0004cf e070                      		ldi3	YL, YH, temp4, START_DELAY_US * CPU_MHZ
0004d0 2ea7                      		mov	temp7, temp4
0004d1 9180 0061                 		lds	temp1, goodies
0004d3 3082                      		cpi	temp1, 2		; After some good commutations,
0004d4 f430                      		brcc	wait_startup1		; skip additional delay injection
0004d5 9170 0075                 		lds	temp4, start_delay
0004d7 e080
0004d8 e890
0004d9 e060                      		ldi3	temp1, temp2, temp3, START_DSTEP_US * CPU_MHZ * 0x100
0004da dd7f                      		rcall	update_timing_add_degrees	; Add temp4 (start_delay) START_DSTEPs of wait
0004db ddec                      wait_startup1:	rcall	set_ocr1a_rel
0004dc ddfa                      		rcall	wait_OCT1_tot
0004dd e0c0
0004de ebd8
0004df e07b                      		ldi3	YL, YH, temp4, TIMEOUT_START * CPU_MHZ
0004e0 2ea7                      		mov	temp7, temp4
0004e1 dde6                      		rcall	set_ocr1a_rel
                                 ; Powered startup: Use a fixed (long) ZC check count until goodies reaches
                                 ; ENOUGH_GOODIES and the STARTUP flag is cleared.
0004e2 efaf                      		ldi	XL, 0xff * CPU_MHZ / 16
0004e3 cfcf                      		rjmp	wait_for_edge1
                                 
                                 ;-----bko-----------------------------------------------------------------
                                 ; init after reset
                                 
                                 ; The reset vector points here, right at the end of the main program.
                                 ; This nop-sleds to the boot loader if the program flash was incomplete.
                                 reset:
0004e4 ce1e                      		rjmp	main
                                 
                                 .if BOOT_LOADER
                                 .include "boot.inc"
                                 
                                 ;
                                 ; We stay here as long as the input pin is pulled high, which is typical
                                 ; for the Turnigy USB Linker. The Turnigy USB Linker sports a SiLabs MCU
                                 ; (5V tolerant I/O) which converts 9600baud serial output from a SiLabs
                                 ; CP2102 USB-to-serial converter to a half duplex wire encoding which
                                 ; avoids signalling that can look like valid drive pulses. All bits are
                                 ; either one or two pulses, as opposed to a serial UART which could go
                                 ; high or low for a long time. This means it _should_ be safe to signal
                                 ; even to an armed ESC, as long as the low end has not been calibrated
                                 ; or set to start at pulses shorter than the linker timing.
                                 ;
                                 ; All transmissions have a leader of 23 1-bits followed by 1 0-bit.
                                 ; Byte encoding starts at the least significant bit and is 8 bits wide.
                                 ; Measuring the Turnigy USB Linker results in the following timings:
                                 ; 1-bits are encoded as 62.0us high, 72.0us low.
                                 ; 0-bits are encoded as 27.7us high, 34.4us low, 34.4us high, 37.7 low.
                                 ; Bit encoding takes about 134us in total.
                                 ; End of encoding adds 34.4us high, then returns to input/pull-up mode.
                                 ; Minimum restart time is 37.0us in input state before the next leader.
                                 ;
                                 ; For this implementation, we always learn the actual timing from the
                                 ; host's leader. The USB linker's implementation seems to accept faster
                                 ; or slower responses, but faster will cause drops between the host and
                                 ; its serial-to-USB conversion at 9600baud, so we always try to match or
                                 ; be slower than the host's timing. It works to use an even fraction for
                                 ; the actual bit timing, but since the total doesn't quite fit in a byte
                                 ; at clk/8 at 16MHz, we store and use the high and low times separately.
                                 ; This implementation should work with much faster pulses than currently
                                 ; used by the USB linker.
                                 ;
                                 ; We support self-flashing ourselves (yo dawg), but doing so in a way
                                 ; that can still respond after each page update is a bit tricky. Some
                                 ; nops are present for future expansion without bumping addresses.
                                 ;
                                 ; We implement STK500v2, as recommended by the avrdude author, rather
                                 ; than implementing a random new protocol. STK500v2 is the only serial
                                 ; protocol that passes the chip signature bytes directly instead of
                                 ; using a lookup table. However, avrdude uses CMD_SPI_MULTI to get
                                 ; these, which is for direct SPI access. We have to catch this and fake
                                 ; the response. We respond to CMD_SIGN_ON with "AVRISP_2", which keeps
                                 ; all messages in the same format and with xor-checksums. We could say
                                 ; "AVRISP_MK2" and drop the message structure after sign-on, but then
                                 ; there is nothing to synchronize messages or do checksums.
                                 ;
                                 ; Note that to work with the Turnigy USB linker, the baud rate must be
                                 ; set to 9600.
                                 ;
                                 ; There seem to be some bugs in the USB linker implementation. With a gap
                                 ; of 5.35ms - 5.75ms between two test characters, the decision seems to
                                 ; be made that another byte is not ready to fit in time, and a second
                                 ; leader is scheduled to start after the minimum restart gap. However,
                                 ; the second byte seems to make it in the first transmission after all,
                                 ; leaving the second one with an empty body. We will process the packet
                                 ; at the end of receiving it, but we won't reply until there is silence,
                                 ; so this should cause no ill effect. However, with a gap of 5.8ms, the
                                 ; linker holds the line low for the duration of the second byte (1056us),
                                 ; drives high for 34.4us, returns to input mode for 447us, then starts a
                                 ; new leader with an empty body. This is not recoverable and may cause us
                                 ; to exit to the application.
                                 ;--
                                 ; Registers:
                                 ; r0: Temporary, spm data (temp5)
                                 ; r1: Temporary, spm data (temp6)
                                 ; r2: Half-bit low time in timer2 ticks
                                 ; r3: Half-bit high time in timer2 ticks
                                 ; r4: Quarter-bit average time in timer2 ticks
                                 ; r5: stk500v2 message checksum (xor)
                                 ; r6: stk500v2 message length low
                                 ; r7: stk500v2 message length high
                                 ; r8: 7/8th bit time in timer2 ticks
                                 ; r9: stk500v2 sequence number
                                 ; r10: Doubled (word) address l
                                 ; r11: Doubled (word) address h
                                 ; r12: Address l
                                 ; r13: Address h
                                 ; r14: Temporary (for checking TIFR, Z storage) (temp7)
                                 ; r15: Temporary (Z storage)
                                 ; r16: Zero
                                 ; r17: EEPROM read/write flags
                                 ; r18: Unused
                                 ; r19: Unused
                                 ; r20: Set for clearing TOV2/OCF2 flags
                                 ; r21: Timeout
                                 ; r22: Byte storage for bit shifting rx/tx (temp3)
                                 ; r23: Temporary (temp4)
                                 ; r24: Loop counter (temp1)
                                 ; r25: Loop counter (temp2)
                                 ; X: TX pointer
                                 ; Y: RX pointer
                                 ; Z: RX jump state pointer
                                 ;
                                 ; We keep the RX buffer just past start of RAM,
                                 ; and start building the response at the start of ram.
                                 ; The whole RAM area is used as the RX/TX buffer.
                                 .equ	RX_BUFFER = SRAM_START + 32
                                 .equ	TX_BUFFER = SRAM_START
                                 
                                 ; Number of RX timeouts / unsuccessful restarts before exiting boot loader
                                 ; If we get stray pulses or continuous high/low with no successful bytes
                                 ; received, we will exit the boot loader after this many tries.
                                 .equ	BOOT_RX_TRIES = 20
                                 
                                 ; STK message constants
                                 .equ	MESSAGE_START			= 0x1b
                                 .equ	TOKEN				= 0x0e
                                 
                                 ; STK general command constants
                                 .equ	CMD_SIGN_ON			= 0x01
                                 .equ	CMD_SET_PARAMETER		= 0x02
                                 .equ	CMD_GET_PARAMETER		= 0x03
                                 .equ	CMD_SET_DEVICE_PARAMETERS	= 0x04
                                 .equ	CMD_OSCCAL			= 0x05
                                 .equ	CMD_LOAD_ADDRESS		= 0x06
                                 .equ	CMD_FIRMWARE_UPGRADE		= 0x07
                                 .equ	CMD_CHECK_TARGET_CONNECTION	= 0x0d
                                 .equ	CMD_LOAD_RC_ID_TABLE		= 0x0e
                                 .equ	CMD_LOAD_EC_ID_TABLE		= 0x0f
                                 
                                 ; STK ISP command constants
                                 .equ	CMD_ENTER_PROGMODE_ISP		= 0x10
                                 .equ	CMD_LEAVE_PROGMODE_ISP		= 0x11
                                 .equ	CMD_CHIP_ERASE_ISP		= 0x12
                                 .equ	CMD_PROGRAM_FLASH_ISP		= 0x13
                                 .equ	CMD_READ_FLASH_ISP		= 0x14
                                 .equ	CMD_PROGRAM_EEPROM_ISP		= 0x15
                                 .equ	CMD_READ_EEPROM_ISP		= 0x16
                                 .equ	CMD_PROGRAM_FUSE_ISP		= 0x17
                                 .equ	CMD_READ_FUSE_ISP		= 0x18
                                 .equ	CMD_PROGRAM_LOCK_ISP		= 0x19
                                 .equ	CMD_READ_LOCK_ISP		= 0x1a
                                 .equ	CMD_READ_SIGNATURE_ISP		= 0x1b
                                 .equ	CMD_READ_OSCCAL_ISP		= 0x1c
                                 .equ	CMD_SPI_MULTI			= 0x1d
                                 
                                 ; STK status constants
                                 .equ	STATUS_CMD_OK			= 0x00
                                 .equ	STATUS_CMD_TOUT			= 0x80
                                 .equ	STATUS_RDY_BSY_TOUT		= 0x81
                                 .equ	STATUS_SET_PARAM_MISSING	= 0x82
                                 .equ	STATUS_CMD_FAILED		= 0xc0
                                 .equ	STATUS_CKSUM_ERROR		= 0xc1
                                 .equ	STATUS_CMD_UNKNOWN		= 0xc9
                                 .equ	STATUS_CMD_ILLEGAL_PARAMETER	= 0xca
                                 
                                 ; STK parameter constants
                                 .equ	PARAM_BUILD_NUMBER_LOW		= 0x80
                                 .equ	PARAM_BUILD_NUMBER_HIGH		= 0x81
                                 .equ	PARAM_HW_VER			= 0x90
                                 .equ	PARAM_SW_MAJOR			= 0x91
                                 .equ	PARAM_SW_MINOR			= 0x92
                                 .equ	PARAM_VTARGET			= 0x94
                                 .equ	PARAM_VADJUST			= 0x95 ; STK500 only
                                 .equ	PARAM_OSC_PSCALE		= 0x96 ; STK500 only
                                 .equ	PARAM_OSC_CMATCH		= 0x97 ; STK500 only
                                 .equ	PARAM_SCK_DURATION		= 0x98 ; STK500 only
                                 .equ	PARAM_TOPCARD_DETECT		= 0x9a ; STK500 only
                                 .equ	PARAM_STATUS			= 0x9c ; STK500 only
                                 .equ	PARAM_DATA			= 0x9d ; STK500 only
                                 .equ	PARAM_RESET_POLARITY		= 0x9e ; STK500 only, and STK600 FW version <= 2.0.3
                                 .equ	PARAM_CONTROLLER_INIT		= 0x9f
                                 
                                 ; Support listening on ICP pin (on AfroESCs)
                                 .if defined(USE_ICP) && USE_ICP
                                 .else
                                 .equ	RCP_PORT = PORTD
                                 .equ	RCP_PIN = PIND
                                 .equ	RCP_DDR = DDRD
                                 .endif
                                 
                                 ; THIRDBOOTSTART on the ATmega8 is 0xe00.
                                 ; Fuses should have BOOTSZ1 set, BOOTSZ0 unset, BOOTRST set.
                                 ; Last nibble of hfuse should be A or 2 to save EEPROM on chip erase.
                                 ; Do not set WTDON. Implementing support for it here is big/difficult.
                                 .if !defined(BOOT_START)
                                 .endif
                                 .org BOOT_START
000e00 e0e4                      boot_reset:	ldi	ZL, high(RAMEND)	; Set up stack
000e01 e5ff                      		ldi	ZH, low(RAMEND)
000e02 bffe                      		out	SPH, ZH
000e03 bfed                      		out	SPL, ZL
000e04 e000                      		ldi	r16, 0			; Use r16 as zero
000e05 ebec                      		ldi	ZL, low(stk_rx_start)
000e06 e0fe                      		ldi	ZH, high(stk_rx_start)
000e07 e8c0                      		ldi	YL, low(RX_BUFFER)
000e08 e0d0                      		ldi	YH, high(RX_BUFFER)
000e09 e6a0                      		ldi	XL, low(TX_BUFFER)
000e0a e0b0                      		ldi	XH, high(TX_BUFFER)
000e0b e042                      		ldi	r20, (1<<CS21)		; timer2: clk/8 ... 256 ticks @ 16MHz = 128us; @ 8MHz = 256us
000e0c bd45                      		out	TCCR2, r20
000e0d ee5c                      		ldi	r21, -BOOT_RX_TRIES
000e0e 9553                      boot_rx_time:	inc	r21
000e0f f071                      		breq	boot_exit		; Exit if too many unsuccessful rx restarts
000e10 ec40                      		ldi	r20, (1<<TOV2)+(1<<OCF2)
000e11 bd04                      		out	TCNT2, r16		; Start TCNT2 at 0
000e12 bf48                      		out	TIFR, r20		; Clear overflow flags
000e13 36a0                      boot_rx_time1:	cpi	XL, low(TX_BUFFER)
000e14 f019                      		breq	boot_rx_no_tx		; Skip transmit if TX_BUFFER empty
000e15 b6e8                      		in	r14, TIFR
000e16 fce6                      		sbrc	r14, TOV2		; Transmit only once timer has wrapped
000e17 c046                      		rjmp	boot_tx_bytes
000e18 9982                      boot_rx_no_tx:	sbic	RCP_PIN, rcp_in
000e19 cff9                      		rjmp	boot_rx_time1		; Loop while high, waiting for low edge
000e1a bd04                      		out	TCNT2, r16
000e1b bf48                      		out	TIFR, r20
000e1c b6e8                      boot_rx_time2:	in	r14, TIFR
000e1d fce6                      		sbrc	r14, TOV2
000e1e c1e1                      boot_exit:	rjmp	FLASHEND + 1		; Low too long, exit boot loader
000e1f 9b82                      		sbis	RCP_PIN, rcp_in		; Loop while low
000e20 cffb                      		rjmp	boot_rx_time2
000e21 bd04                      		out	TCNT2, r16
000e22 bf48                      		out	TIFR, r20		; Start measuring high time
000e23 b6e8                      boot_rx_time3:	in	r14, TIFR
000e24 fce6                      		sbrc	r14, TOV2
000e25 cfe8                      		rjmp	boot_rx_time		; High too long, start over
000e26 9982                      		sbic	RCP_PIN, rcp_in		; Loop while high, waiting for low edge
000e27 cffb                      		rjmp	boot_rx_time3
000e28 b434                      		in	r3, TCNT2		; Save learned high time
000e29 bd04                      		out	TCNT2, r16
000e2a bf48                      		out	TIFR, r20		; Start measuring low time
000e2b b6e8                      boot_rx_time4:	in	r14, TIFR
000e2c fce6                      		sbrc	r14, TOV2
000e2d c1d2                      		rjmp	FLASHEND + 1		; Low too long, exit boot loader
000e2e 9b82                      		sbis	RCP_PIN, rcp_in		; Loop while low, waiting for high edge
000e2f cffb                      		rjmp	boot_rx_time4
000e30 b424                      		in	r2, TCNT2		; Save learned low time
000e31 2c02                      		mov	r0, r2
000e32 0c03                      		add	r0, r3
                                 	; C:r0 now contains the number of timer2 ticks for one bit.
                                 	; 7/8ths of this should be just enough to see two high to
                                 	; low transitions for 0-bits, or one high-to-low for 1-bits.
                                 	; Subtract 1/8th to get a time at which we check the edge
                                 	; count and then wait for the next bit.
000e33 2c80                      		mov	r8, r0			; C:r8 holds full time (9-bit)
000e34 9407                      		ror	r0			; r0 now holds half time (8-bit)
000e35 9406                      		lsr	r0
000e36 2c40                      		mov	r4, r0			; Save quarter bit time (for tx)
000e37 9406                      		lsr	r0
000e38 0880                      		sbc	r8, r0			; Subtract 1/8th, rounding, unwrapping from 9th bit overflow
000e39 9480                      		com	r8			; Store one's complement for setting timer value
000e3a 9420                      		com	r2			; Same for half-bit low time
000e3b 9430                      		com	r3			; Same for half-bit high time
000e3c 9440                      		com	r4			; Same for quarter-bit average time
000e3d ee60                      		ldi	r22, 0b11100000		; Start with two leader bits and sentinel bit preloaded
000e3e e083                      		ldi	r24, 3			; Skip storing of 3 leader bytes
                                 	; Bit-decoding: Set high-to-low edge counting timer (r8), and wait
                                 	; for it to expire.
000e3f bc84                      boot_rx:	out	TCNT2, r8
000e40 bf48                      		out	TIFR, r20
000e41 b6e8                      boot_rx0:	in	r14, TIFR
000e42 fce6                      		sbrc	r14, TOV2
000e43 c1bc                      		rjmp	FLASHEND + 1		; Low too long, exit boot loader
000e44 9b82                      		sbis	RCP_PIN, rcp_in
000e45 cffb                      		rjmp	boot_rx0
000e46 bc84                      		out	TCNT2, r8		; Count falling edges for 7/8th of one bit time
000e47 bf48                      		out	TIFR, r20
000e48 b6e8                      boot_rx1:	in	r14, TIFR
000e49 fce6                      		sbrc	r14, TOV2
000e4a cfc3                      		rjmp	boot_rx_time		; High too long (or EOT), start over
000e4b 9982                      		sbic	RCP_PIN, rcp_in
000e4c cffb                      		rjmp	boot_rx1
000e4d 9408                      		sec				; Receiving 1-bit
000e4e b6e8                      boot_rx2:	in	r14, TIFR
000e4f fce6                      		sbrc	r14, TOV2
000e50 c023                      		rjmp	boot_rx_bit		; Timeout, must be 1-bit
000e51 9b82                      		sbis	RCP_PIN, rcp_in
000e52 cffb                      		rjmp	boot_rx2
000e53 b6e8                      boot_rx3:	in	r14, TIFR
000e54 fce6                      		sbrc	r14, TOV2
000e55 cfb8                      		rjmp	boot_rx_time		; Hmm, timed out during second high
000e56 9982                      		sbic	RCP_PIN, rcp_in
000e57 cffb                      		rjmp	boot_rx3
000e58 9488                      		clc				; Receiving 0-bit
000e59 b6e8                      boot_rx4:	in	r14, TIFR
000e5a 9b82                      		sbis	RCP_PIN, rcp_in
000e5b fce6                      		sbrc	r14, TOV2
000e5c c017                      		rjmp	boot_rx_bit		; Timeout or high, must be 0-bit
000e5d cffb                      		rjmp	boot_rx4
                                 
                                 boot_tx_bytes:
000e5e bc43                      		out	OCR2, r4		; Set OCF2 at quarter timing
000e5f e187                      		ldi	r24, 23			; Leader is 23 1-bits, 1 0-bit
                                 boot_tx_leader:
000e60 9a92                      		sbi	RCP_PORT, rcp_in	; Drive high
000e61 9a8a                      		sbi	RCP_DDR, rcp_in
000e62 bc34                      		out	TCNT2, r3
000e63 bf48                      		out	TIFR, r20
000e64 b6e8                      boot_tx_lead1:	in	r14, TIFR
000e65 fee6                      		sbrs	r14, TOV2
000e66 cffd                      		rjmp	boot_tx_lead1
000e67 9892                      		cbi	RCP_PORT, rcp_in	; Drive low
000e68 bc24                      		out	TCNT2, r2
000e69 bf48                      		out	TIFR, r20
000e6a b6e8                      boot_tx_lead2:	in	r14, TIFR
000e6b fee6                      		sbrs	r14, TOV2
000e6c cffd                      		rjmp	boot_tx_lead2
000e6d 958a                      		dec	r24
000e6e f789                      		brne	boot_tx_leader
                                 
000e6f e6c0                      		ldi	YL, low(TX_BUFFER)
000e70 e0d0                      		ldi	YH, high(TX_BUFFER)
                                 
000e71 e060                      		ldi	r22, 0
000e72 e081                      		ldi	r24, 1
000e73 c00b                      		rjmp	boot_tx_bits		; Send single start bit first
                                 
                                 	; Interleaving rx/tx here to avoid branching trampolines.
000e74 9567                      boot_rx_bit:	ror	r22			; Roll rx bit in carry into r22
000e75 f648                      		brcc	boot_rx			; More bits to receive unless sentinel bit reached carry flag
000e76 5081                      		subi	r24, 1
000e77 f568                      		brcc	boot_rx_skip		; Don't store leader bytes
000e78 ee5c                      		ldi	r21, -BOOT_RX_TRIES	; Clear timeout on byte received
000e79 9409                      		ijmp				; Jump to current state handler
                                 
000e7a 17ca                      boot_tx:	cp	YL, XL
000e7b 07db                      		cpc	YH, XH
000e7c f0d1                      		breq	boot_tx_end
000e7d 9169                      		ld	r22, Y+
000e7e e088                      		ldi	r24, 8			; Send 8 bits
000e7f 9566                      boot_tx_bits:	lsr	r22			; Put next bit in carry flag
000e80 9a92                      		sbi	RCP_PORT, rcp_in	; Drive high
000e81 bc34                      		out	TCNT2, r3
000e82 bf48                      		out	TIFR, r20
000e83 b6e8                      boot_tx1:	in	r14, TIFR
000e84 f010                      		brcs	boot_tx2
000e85 fce7                      		sbrc	r14, OCF2
000e86 bb02                      		out	RCP_PORT, r16		; Drive low
000e87 fee6                      boot_tx2:	sbrs	r14, TOV2
000e88 cffa                      		rjmp	boot_tx1
000e89 9892                      		cbi	RCP_PORT, rcp_in
000e8a f008                      		brcs	boot_tx_low
000e8b 9a92                      		sbi	RCP_PORT, rcp_in	; Drive high
000e8c bc24                      boot_tx_low:	out	TCNT2, r2
000e8d bf48                      		out	TIFR, r20
000e8e b6e8                      boot_tx3:	in	r14, TIFR
000e8f f010                      		brcs	boot_tx4
000e90 fce7                      		sbrc	r14, OCF2
000e91 bb02                      		out	RCP_PORT, r16		; Drive low
000e92 fee6                      boot_tx4:	sbrs	r14, TOV2
000e93 cffa                      		rjmp	boot_tx3
000e94 958a                      		dec	r24
000e95 f749                      		brne	boot_tx_bits
000e96 cfe3                      		rjmp	boot_tx
                                 	; Go high for a quarter bit time at the end
000e97 9a92                      boot_tx_end:	sbi	RCP_PORT, rcp_in	; Drive high
000e98 bc34                      		out	TCNT2, r3
000e99 bf48                      		out	TIFR, r20
000e9a e8c0                      		ldi	YL, low(RX_BUFFER)
000e9b e0d0                      		ldi	YH, high(RX_BUFFER)
000e9c e6a0                      		ldi	XL, low(TX_BUFFER)
000e9d e0b0                      		ldi	XH, high(TX_BUFFER)
000e9e b6e8                      boot_tx_end1:	in	r14, TIFR
000e9f fee7                      		sbrs	r14, OCF2
000ea0 cffd                      		rjmp	boot_tx_end1
000ea1 988a                      		cbi	RCP_DDR, rcp_in		; Stop driving
000ea2 bb02                      		out	RCP_PORT, r16		; Turn off
000ea3 cf6a                      		rjmp	boot_rx_time
                                 
000ea4 e080                      boot_rx_cont:	ldi	r24, 0
000ea5 e860                      boot_rx_skip:	ldi	r22, 0b10000000		; Restart with sentinel bit preloaded
000ea6 cf98                      		rjmp	boot_rx
                                 
                                 ; Simple implementation of stk500v2
                                 ; Do not clobber registers needed to reply: r2, r3, r8, r16, r20
000ea7 ebec                      stk_rx_restart:	ldi	ZL, low(stk_rx_start)
000ea8 e0fe                      		ldi	ZH, high(stk_rx_start)
000ea9 e8c0                      		ldi	YL, low(RX_BUFFER)
000eaa e0d0                      		ldi	YH, high(RX_BUFFER)
000eab cff8                      		rjmp	boot_rx_cont
000eac 9000 0000                 		lds	r0, 0			; Future expansion nops
000eae 9000 0000                 		lds	r0, 0
000eb0 9000 0000                 		lds	r0, 0
000eb2 9000 0000                 		lds	r0, 0
000eb4 9000 0000                 		lds	r0, 0
000eb6 9000 0000                 		lds	r0, 0
000eb8 9000 0000                 		lds	r0, 0
000eba 9000 0000                 		lds	r0, 0
000ebc 0000                      stk_rx_start:	nop				; Future expansion nops
000ebd 0000                      		nop
000ebe 316b                      		cpi	r22, MESSAGE_START
000ebf f721                      		brne	boot_rx_cont
000ec0 2e56                      		mov	r5, r22			; Start checksum in r5
000ec1 9637                      		adiw	ZL, stk_rx_seq - stk_rx_start
000ec2 cfe1                      		rjmp	boot_rx_cont
000ec3 2e96                      stk_rx_seq:	mov	r9, r22			; Store sequence number in r9
000ec4 2656                      		eor	r5, r22
000ec5 9634                      		adiw	ZL, stk_rx_size_h - stk_rx_seq
000ec6 cfdd                      		rjmp	boot_rx_cont
000ec7 2e76                      stk_rx_size_h:	mov	r7, r22			; Store message length high in r7
000ec8 2656                      		eor	r5, r22
000ec9 9634                      		adiw	ZL, stk_rx_size_l - stk_rx_size_h
000eca cfd9                      		rjmp	boot_rx_cont
000ecb 2e66                      stk_rx_size_l:	mov	r6, r22			; Store message length low in r6
000ecc 2656                      		eor	r5, r22
000ecd 9634                      		adiw	ZL, stk_rx_token - stk_rx_size_l
000ece cfd5                      		rjmp	boot_rx_cont
000ecf 306e                      stk_rx_token:	cpi	r22, TOKEN
000ed0 f6b1                      		brne	stk_rx_restart
000ed1 2656                      		eor	r5, r22
000ed2 9635                      		adiw	ZL, stk_rx_body - stk_rx_token
000ed3 cfd0                      		rjmp	boot_rx_cont
000ed4 9369                      stk_rx_body:	st	Y+, r22
000ed5 2656                      		eor	r5, r22
000ed6 35cf                      		cpi	YL, low(RAMEND)
000ed7 e084                      		ldi	r24, high(RAMEND)
000ed8 07d8                      		cpc	YH, r24
000ed9 f668                      		brcc	stk_rx_restart
000eda e081                      		ldi	r24, 1
000edb 1a68                      		sub	r6, r24
000edc 0a70                      		sbc	r7, r16
000edd f409                      		brne	stx_rx_cont
000ede 963c                      		adiw	ZL, stk_rx_cksum - stk_rx_body
000edf cfc4                      stx_rx_cont:	rjmp	boot_rx_cont
000ee0 1165                      stk_rx_cksum:	cpse	r22, r5
000ee1 cfc5                      		rjmp	stk_rx_restart		; Restart if bad checksum
                                 stk_rx:
                                 	; Good checksum -- process message
                                 	; We can use Z and Y now, since we will set it back to start in stk_rx_restart
                                 	; Load the first three bytes into r22, r25, r24.
000ee2 e8c0                      		ldi	YL, low(RX_BUFFER)	; Number of bytes to rx
000ee3 e0d0                      		ldi	YH, high(RX_BUFFER)
000ee4 9169                      		ld	r22, Y+			; Command byte
000ee5 9199                      		ld	r25, Y+			; Parameter or address/count high,
000ee6 9189                      		ld	r24, Y+			; Address/count low
                                 	; Start the beginning of a typical response message
000ee7 01fd                      		movw	ZL, XL			; Start checksumming from here
000ee8 e17b                      		ldi	r23, MESSAGE_START
000ee9 8370                      		st	Z, r23			; Message start
000eea 8291                      		std	Z+1, r9			; Sequence number
000eeb 8302                      		std	Z+2, r16		; Message body size high
000eec e072                      		ldi	r23, 2
000eed 8373                      		std	Z+3, r23		; Message body size low
000eee e07e                      		ldi	r23, TOKEN
000eef 8374                      		std	Z+4, r23		; Message token
000ef0 8365                      		std	Z+5, r22		; Command
000ef1 8306                      		std	Z+6, r16		; Typical status OK (STATUS_CMD_OK)
000ef2 9617                      		adiw	XL, 7
                                 	; Check which command we received
000ef3 3061                      		cpi	r22, CMD_SIGN_ON
000ef4 f4a1                      		brne	scmd1			; Inverted tests for branch reach
000ef5 e08b                      		ldi	r24, SIGNATURE_LENGTH + 3
000ef6 8383                      		std	Z+3, r24		; Message body size low
000ef7 e088                      		ldi	r24, SIGNATURE_LENGTH
000ef8 938d                      		st	X+, r24			; Signature size
000ef9 01ef                      		movw	YL, ZL
000efa edec                      		ldi	ZL, low(avrisp_response_w << 1)
000efb e1ff                      		ldi	ZH, high(avrisp_response_w << 1)
000efc 9185                      scmd_sign_on1:	lpm	r24, Z+
000efd 938d                      		st	X+, r24
000efe 3ee4                      		cpi	ZL, low((avrisp_response_w << 1) + SIGNATURE_LENGTH)
000eff f7e1                      		brne	scmd_sign_on1
000f00 01fe                      		movw	ZL, YL
                                 scmd_send_chksum:
000f01 9181                      		ld	r24, Z+
000f02 9161                      chksum1:	ld	r22, Z+
000f03 2786                      		eor	r24, r22
000f04 17ea                      		cp	ZL, XL
000f05 07fb                      		cpc	ZH, XH
000f06 f7d9                      		brne	chksum1
000f07 938d                      		st	X+, r24			; Store xor checksum
000f08 cf9e                      		rjmp	stk_rx_restart
000f09 316d                      scmd1:		cpi	r22, CMD_SPI_MULTI
000f0a f551                      		brne	scmd2
                                 	; avrdude uses spi_multi spi pass-through mode to check fuse bytes,
                                 	; so we emulate this. Constants from the Arduino stk500v2 example
                                 	; boot loader.
000f0b 2f79                      		mov	r23, r25		; Save NumTx in r23
000f0c e090                      		ldi	r25, 0			; Zero-extend r24
000f0d 9603                      		adiw	r24, 3			; Command, status, rx'd bytes, status
000f0e 8383                      		std	Z+3, r24		; Message body size low
000f0f 8392                      		std	Z+2, r25		; Message body size high
000f10 9703                      		sbiw	r24, 3			; Back to just byte count
000f11 930d                      scmd_multi1:	st	X+, r16			; Fill return buffer with zeroes
000f12 958a                      		dec	r24
000f13 f7e9                      		brne	scmd_multi1
                                 	; Check for signature probe
                                 	; Mirror address in result
000f14 9189                      		ld	r24, Y+			; RxStartAddr
000f15 9169                      		ld	r22, Y+			; TxData
000f16 3360                      		cpi	r22, 0x30		; Read signature bytes?
000f17 0780                      		cpc	r24, r16		; Only support RxStartAddr == 0
000f18 e094                      		ldi	r25, 4
000f19 0779                      		cpc	r23, r25		; Only support NumRx == 4
000f1a f479                      		brne	scmd_multi3
000f1b 8760                      		std	Z+8, r22		; Echo back command
000f1c 9189                      		ld	r24, Y+			; Address high
000f1d 3080                      		cpi	r24, 0
000f1e f459                      		brne	scmd_multi3
000f1f 9169                      		ld	r22, Y+			; Address low
000f20 3060                      		cpi	r22, 0
000f21 e18e                      		ldi	r24, SIGNATURE_000	; atmega8 == 0x1e 0x93 0x07
000f22 f031                      		breq	scmd_multi2
000f23 3061                      		cpi	r22, 1
000f24 e983                      		ldi	r24, SIGNATURE_001
000f25 f019                      		breq	scmd_multi2
000f26 3062                      		cpi	r22, 2
000f27 e087                      		ldi	r24, SIGNATURE_002
000f28 f409                      		brne	scmd_multi3
000f29 8782                      scmd_multi2:	std	Z+10, r24		; Signature byte
000f2a 930d                      scmd_multi3:	st	X+, r16			; STATUS_CMD_OK
000f2b cfd5                      		rjmp	scmd_send_chksum
                                 
                                 scmd_load_address:
000f2c 1780                      		cp	r24, r16
000f2d 0790                      		cpc	r25, r16
000f2e f509                      		brne	scmd_fail
000f2f 90d9                      		ld	r13, Y+			; Save address
000f30 90c9                      		ld	r12, Y+
000f31 0156                      		movw	r10, r12
000f32 0caa                      		lsl	r10
000f33 1cbb                      		rol	r11
000f34 cfcc                      		rjmp	scmd_send_chksum
                                 scmd2:
000f35 3063                      		cpi	r22, CMD_GET_PARAMETER
000f36 f0e1                      		breq	scmd_get_parameter
000f37 3062                      		cpi	r22, CMD_SET_PARAMETER
000f38 f241                      		breq	scmd_send_chksum	; Blind OK
000f39 3160                      		cpi	r22, CMD_ENTER_PROGMODE_ISP
000f3a f231                      		breq	scmd_send_chksum	; Blind OK
000f3b 3161                      		cpi	r22, CMD_LEAVE_PROGMODE_ISP
000f3c f221                      		breq	scmd_send_chksum	; Blind OK
000f3d 3066                      		cpi	r22, CMD_LOAD_ADDRESS
000f3e f369                      		breq	scmd_load_address
000f3f 3162                      		cpi	r22, CMD_CHIP_ERASE_ISP
000f40 f1f1                      		breq	scmd_chip_erase
                                 	; Commands after here are all read/write eeprom/flash types
000f41 3f83                      		cpi	r24, low(RAMEND - TX_BUFFER - 12)
000f42 e073                      		ldi	r23, high(RAMEND - TX_BUFFER - 12)
000f43 0797                      		cpc	r25, r23
000f44 f458                      		brcc	scmd_fail		; Not enough RAM for that many bytes
000f45 3164                      		cpi	r22, CMD_READ_FLASH_ISP
000f46 f109                      		breq	scmd_read_flash
000f47 3166                      		cpi	r22, CMD_READ_EEPROM_ISP
000f48 f169                      		breq	scmd_read_eeprom
000f49 9627                      		adiw	YL, 7			; Skip useless write command bytes
000f4a 3165                      		cpi	r22, CMD_PROGRAM_EEPROM_ISP
000f4b f1c1                      		breq	scmd_program_eeprom
000f4c 3163                      		cpi	r22, CMD_PROGRAM_FLASH_ISP
000f4d f1f9                      		breq	scmd_program_flash
000f4e 0000                      		nop				; Future expansion
000f4f 0000                      		nop
000f50 ec80                      scmd_fail:	ldi	r24, STATUS_CMD_FAILED
000f51 8386                      		std	Z+6, r24
000f52 cfae                      		rjmp	scmd_send_chksum
                                 
                                 scmd_get_parameter:
000f53 3990                      		cpi	r25, PARAM_HW_VER
000f54 e08f                      		ldi	r24, 0xf
000f55 f071                      		breq	scmd_get_parameter_good
000f56 3991                      		cpi	r25, PARAM_SW_MAJOR
000f57 e082                      		ldi	r24, 0x2
000f58 f059                      		breq	scmd_get_parameter_good
000f59 3992                      		cpi	r25, PARAM_SW_MINOR
000f5a e08a                      		ldi	r24, 0xa
000f5b f041                      		breq	scmd_get_parameter_good
000f5c 3994                      		cpi	r25, PARAM_VTARGET
000f5d e382                      		ldi	r24, 50
000f5e f029                      		breq	scmd_get_parameter_good
000f5f 3890                      		cpi	r25, PARAM_BUILD_NUMBER_LOW
000f60 e080                      		ldi	r24, 0
000f61 f011                      		breq	scmd_get_parameter_good
000f62 3891                      		cpi	r25, PARAM_BUILD_NUMBER_HIGH
000f63 f761                      		brne	scmd_fail
                                 scmd_get_parameter_good:
000f64 938d                      		st	X+, r24
000f65 e083                      		ldi	r24, 3
000f66 8383                      		std	Z+3, r24		; Message body size low
000f67 cf99                      		rjmp	scmd_send_chksum
                                 
                                 scmd_read_flash:
000f68 d049                      		rcall	scmd_blob_message_size
000f69 01ef                      		movw	YL, ZL			; Save Z
000f6a 01f5                      		movw	ZL, r10			; lpm can only use Z
                                 scmd_read_rwwse_wait:
000f6b d08f                      		rcall	boot_rwwsb_wt
000f6c fd76                      		sbrc	r23, RWWSB
000f6d cffd                      		rjmp	scmd_read_rwwse_wait	; Wait if flash still completing
000f6e 9165                      scmd_read_fl1:	lpm	r22, Z+
000f6f 936d                      		st	X+, r22
000f70 9701                      		sbiw	r24, 1
000f71 f7e1                      		brne	scmd_read_fl1
000f72 015f                      		movw	r10, ZL			; Save updated word address
000f73 01fe                      		movw	ZL, YL			; Restore Z
000f74 930d                      		st	X+, r16			; STATUS_CMD_OK at end
000f75 cf8b                      		rjmp	scmd_send_chksum
                                 
                                 scmd_read_eeprom:
000f76 d03b                      		rcall	scmd_blob_message_size
000f77 e011                      		ldi	r17, (1<<EERE)
000f78 d03e                      scmd_read_ee1:	rcall	boot_eeprom_rw		; Uses and increments byte address
000f79 b36d                      		in	r22, EEDR
000f7a 936d                      		st	X+, r22
000f7b 9701                      		sbiw	r24, 1
000f7c f7d9                      		brne	scmd_read_ee1
000f7d 930d                      		st	X+, r16			; STATUS_CMD_OK at end
000f7e cf82                      		rjmp	scmd_send_chksum
                                 
                                 ; For chip erase, clear the flash before the boot loader and nuke the EEPROM.
                                 scmd_chip_erase:
000f7f d047                      		rcall	boot_clear_flash	; Also clears r12:r13 for EEPROM address
000f80 0000                      		nop
000f81 e080                      		ldi	r24, low(EEPROMEND+1)
000f82 e092                      		ldi	r25, high(EEPROMEND+1)
000f83 9468                      		set
                                 scmd_program_eeprom:
000f84 e016                      		ldi	r17, (1<<EEMWE)+(1<<EEWE)
000f85 ef6f                      scmd_write_ee1:	ldi	r22, 0xff
000f86 f00e                      		brts	scmd_write_ee2
000f87 9169                      		ld	r22, Y+
000f88 d02e                      scmd_write_ee2:	rcall	boot_eeprom_rw
000f89 9701                      		sbiw	r24, 1
000f8a f7d1                      		brne	scmd_write_ee1
000f8b 94e8                      		clt
000f8c cf74                      		rjmp	scmd_send_chksum
                                 
                                 scmd_program_flash:
000f8d 7f8f                      		cbr	r24, 0			; Round down
000f8e e061                      		ldi	r22, (1<<SPMEN)		; Store to temporary page buffer
000f8f 017f                      		movw	r14, ZL			; Save Z
000f90 01f5                      		movw	ZL, r10			; Load word address for page write
000f91 9009                      scmd_write_fl1:	ld	r0, Y+
000f92 9019                      		ld	r1, Y+
000f93 d068                      		rcall	boot_spm
000f94 9632                      		adiw	ZL, 2
000f95 9702                      		sbiw	r24, 2
000f96 f7d1                      		brne	scmd_write_fl1
000f97 010f                      		movw	r0, ZL			; Stash new address
000f98 01f5                      		movw	ZL, r10			; Load old word address
000f99 0150                      		movw	r10, r0			; Save new word address
000f9a e063                      		ldi	r22, (1<<PGERS)+(1<<SPMEN)
000f9b 3ce0                      		cpi	ZL, low(2*(boot_wr_flash & ~(PAGESIZE-1)))
000f9c e17f                      		ldi	r23, high(2*(boot_wr_flash & ~(PAGESIZE-1)))
000f9d 07f7                      		cpc	ZH, r23
000f9e f019                      		breq	scmd_write_fl3		; Unless we are overwriting it,
000f9f d058                      		rcall	boot_wr_flash		; use the normal boot_wr_flash
000fa0 01f7                      scmd_write_fl2:	movw	ZL, r14			; Restore Z
000fa1 cf5f                      		rjmp	scmd_send_chksum
                                 ; This is a shadow of boot_wr_flash and is to be used while the page containing
                                 ; the usually-used boot_wr_flash is being erased and reflashed.
000fa2 d00b                      scmd_write_fl3:	rcall	scmd_spm		; Erase page
000fa3 e065                      		ldi	r22, (1<<PGWRT)+(1<<SPMEN)
000fa4 d009                      		rcall	scmd_spm		; Write page
000fa5 e161                      		ldi	r22, (1<<RWWSRE)+(1<<SPMEN)
000fa6 d007                      		rcall	scmd_spm		; Re-enable RWW section
000fa7 cff8                      		rjmp	scmd_write_fl2		; Return
000fa8 b777                      scmd_spm_wait:	in	r23, SPMCR		; Wait for previous SPM to finish
000fa9 fd70                      		sbrc	r23, SPMEN
000faa cffd                      		rjmp	scmd_spm_wait
000fab 99e1                      scmd_ee_wait:	sbic	EECR, EEWE		; Wait for EEPROM write to finish
000fac cffe                      		rjmp	scmd_ee_wait
000fad 9508                      		ret
000fae dff9                      scmd_spm:	rcall	scmd_spm_wait
000faf bf67                      		out	SPMCR, r22		; Set SPM mode
000fb0 95e8                      		spm
000fb1 9508                      		ret
                                 
                                 scmd_blob_message_size:
000fb2 9603                      		adiw	r24, 3			; Command, status, (data), status
000fb3 8392                      		std	Z+2, r25		; Message body size high
000fb4 8383                      		std	Z+3, r24		; Message body size low
000fb5 9703                      		sbiw	r24, 3			; Back to just the byte count
000fb6 9508                      		ret
                                 
000fb7 d03a                      boot_eeprom_rw:	rcall	boot_spm_wait
000fb8 badf                      		out	EEARH, r13
000fb9 bace                      		out	EEARL, r12
000fba 9408                      		sec
000fbb 1ec0                      		adc	r12, r16		; Increment address
000fbc 1ed0                      		adc	r13, r16
000fbd 2f76                      		mov	r23, r22		; Save desired value
000fbe 9ae0                      		sbi	EECR, EERE		; Read existing EEPROM byte
000fbf b36d                      		in	r22, EEDR
000fc0 1367                      		cpse	r22, r23		; Return if byte matches
000fc1 ff12                      		sbrs	r17, EEMWE		; Return if only reading
000fc2 9508                      		ret
000fc3 bb7d                      		out	EEDR, r23		; Set new byte
000fc4 9ae2                      		sbi	EECR, EEMWE		; Write arming
000fc5 bb1c                      		out	EECR, r17		; Write
000fc6 9508                      		ret
                                 
                                 ; Erase flash space before boot loader (used for "chip erase")
                                 boot_clear_flash:
000fc7 017f                      		movw	r14, ZL			; Save Z
000fc8 e0e0                      		ldi	ZL, low(2*BOOT_START)	; Start at boot loader
000fc9 e1fc                      		ldi	ZH, high(2*BOOT_START)
000fca e063                      		ldi	r22, (1<<PGERS)+(1<<SPMEN)
000fcb 54e0                      boot_clear_fl1:	subi	ZL, low(2*PAGESIZE)	; Decrement by a page
000fcc 40f0                      		sbci	ZH, high(2*PAGESIZE)
000fcd d02e                      		rcall	boot_spm		; Erase page (never this code)
000fce f7e1                      		brne	boot_clear_fl1
000fcf 016f                      		movw	r12, ZL			; Zero r12:r13 (for EEPROM address later)
000fd0 01f7                      		movw	ZL, r14			; Restore Z
000fd1 9508                      		ret
                                 
                                 ; Pad out the boot loader to work around avrdude verifying gaps
000fd2 0000                      		nop
000fd3 0000                      		nop
                                 
000fd4 0000                      		nop
000fd5 0000                      		nop
000fd6 0000                      		nop
000fd7 0000                      		nop
                                 
000fd8 0000                      		nop
000fd9 0000                      		nop
000fda 0000                      		nop
000fdb 0000                      		nop
                                 
000fdc 0000                      		nop
000fdd 0000                      		nop
000fde 0000                      		nop
000fdf 0000                      		nop
                                 
                                 ; Keep these addresses within a page so that we can self-update.
                                 .org FLASHEND + 1 - 32
                                 description:
000fe0 7468
000fe1 7074
000fe2 2f3a
000fe3 672f
000fe4 7469
000fe5 7568
000fe6 2e62
000fe7 6f63
000fe8 2f6d
000fe9 6973
000fea 2d6d
000feb 742f
000fec 7967
000fed 002f                      	.db "http://github.com/sim-/tgy/", 0	; Hello!
                                 avrisp_response_w:
                                 	.equ SIGNATURE_LENGTH = 8
000fee 5641
000fef 4952
000ff0 5053
000ff1 325f                      	.db "AVRISP_2"				; stk500v2 signature
                                 
000ff2 b777                      boot_spm_wait:	in	r23, SPMCR		; Wait for previous SPM to finish
000ff3 fd70                      		sbrc	r23, SPMEN
000ff4 cffd                      		rjmp	boot_spm_wait
000ff5 99e1                      boot_ee_wait:	sbic	EECR, EEWE		; Wait for EEPROM write to finish
000ff6 cffe                      		rjmp	boot_ee_wait
000ff7 9508                      		ret
000ff8 d003                      boot_wr_flash:	rcall	boot_spm		; Erase page
000ff9 e065                      		ldi	r22, (1<<PGWRT)+(1<<SPMEN)
000ffa d001                      		rcall	boot_spm		; Write page
000ffb e161                      boot_rwwsb_wt:	ldi	r22, (1<<RWWSRE)+(1<<SPMEN)
000ffc dff5                      boot_spm:	rcall	boot_spm_wait
000ffd bf67                      		out	SPMCR, r22		; Set SPM mode
000ffe 95e8                      		spm
000fff 9508                      		ret
                                 .endif


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega8" register use summary:
x  :  10 y  :  19 z  :  24 r0 :  40 r1 :  18 r2 :   7 r3 :   7 r4 :   5 
r5 :   8 r6 :   7 r7 :   3 r8 :  12 r9 :  17 r10:  37 r11:  12 r12:  12 
r13:   5 r14:  39 r15:   2 r16:  46 r17:  43 r18:  22 r19:   0 r20:  42 
r21:  11 r22: 122 r23:  84 r24: 261 r25: 101 r26:  34 r27:  22 r28:  81 
r29:  54 r30:  46 r31:  70 
Registers used: 34 out of 35 (97.1%)

"ATmega8" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  27 add   :  15 adiw  :  22 and   :   0 
andi  :   2 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  14 brcs  :  22 breq  :  37 brge  :   0 brhc  :   0 brhs  :   0 
brid  :   0 brie  :   1 brlo  :   3 brlt  :   0 brmi  :   0 brne  :  48 
brpl  :   2 brsh  :   0 brtc  :   1 brts  :   1 brvc  :   0 brvs  :   0 
bset  :   0 bst   :   1 cbi   :  19 cbr   :  31 clc   :   1 clh   :   0 
cli   :  15 cln   :   0 clr   :   5 cls   :   0 clt   :   1 clv   :   0 
clz   :   0 com   :   8 cp    :  15 cpc   :  27 cpi   :  62 cpse  :  14 
dec   :  17 eor   :  10 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 
ijmp  :   2 in    :  70 inc   :   5 ld    :  16 ldd   :   0 ldi   : 203 
lds   :  71 lpm   :   6 lsl   :   5 lsr   :  10 mov   :  23 movw  :  32 
mul   :  11 muls  :   0 mulsu :   0 neg   :   0 nop   :  19 or    :   0 
ori   :   0 out   : 115 pop   :   2 push  :   0 rcall : 111 ret   :  35 
reti  :  20 rjmp  : 127 rol   :  12 ror   :   9 sbc   :  15 sbci  :   4 
sbi   :  33 sbic  :   7 sbis  :   7 sbiw  :   7 sbr   :  20 sbrc  :  50 
sbrs  :  23 sec   :   2 seh   :   0 sei   :  14 sen   :   0 ser   :   0 
ses   :   0 set   :   1 sev   :   0 sez   :   0 sleep :   0 spm   :   4 
st    :  17 std   :  15 sts   :  47 sub   :  11 subi  :  13 swap  :   0 
tst   :   3 wdr   :  10 
Instructions used: 68 out of 110 (61.8%)

"ATmega8" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x002000   3486     44   3530    8192  43.1%
[.dseg] 0x000060 0x00008e      0     46     46    1024   4.5%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
