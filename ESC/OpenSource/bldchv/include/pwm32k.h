/*
The pwm output is generated by the timer2 running in NORMAL-mode.
The frequency is set to 31.250khz (prescaler = 1)
Since the output is generated by software the irq-routine has to be as short as possible
to save cpu-time. Therefore the isr is written in inline assembler resulting in a total of
4+1+4 cycles.
The shortes outputpulse-width is 9 cycles -> duty_cycle 9/255 ~3.5%

The output is generated by writing 'r16' (pwm-on) or 'r17' (pwm-off) the port.
Pwm will be turned on at timer2 overflow. Pwm will be turned off at ocr2 match.
The PWM is always on in the range PWM_Top <= Pwm_Width <= 0xFF to give a stable "fullpower" setting.
*/

#define PWM_PORT PORTB			// at this_PORT the ist "toggles" the output



//the lower nibble holds the 'switch-pattern'
// the "asm-trick" works only for win-avr gcc !!!!     (as far as i know)
// don't know how to preserve register for exclusiv use in other compilers

volatile register unsigned char PWM_BYTE_ON asm("r16");   // preserve r16 for pwm_data_on
volatile register unsigned char PWM_BYTE_OFF asm("r17");  // preserve r17 for pwm_data_off

//ISR ROUTINES

ISR(TIMER2_COMP_vect, ISR_NAKED)           // no other registers will be altered
{
  //write PWM_BYTE_OFF to PORTB
  asm volatile("out 0x18, r17" "\n\t" 	    //write PORTB
					"reti" "\n\t"
					:: );
}//end of ISR(TI...)

ISR(TIMER2_OVF_vect, ISR_NAKED)           // no other registers will be altered
{
  //write PWM_BYTE_ON to PORTB
  asm volatile("out 0x18, r16" "\n\t"  	//write PORTB
					"reti" "\n\t"
					:: );
}//end of ISR(TI...)


//functions

void init_pwm(void)
{
 volatile uint16_t i,j;

 PORTD=0x00;		//clear so not turning on the fets accidently
 DDRD=0x87;    	//Bit7,2,1,0 are outputs
 PORTB=0x00;		//disable pullups, set output to 0
 DDRB=0x07;			//Bit2:0 are output

 // if you 'love' ;o) your high-side fets, do a precharge of the associated 'C'	
 PORTD=0x07;      // turn on all 3 low-fets, give high side "C" time to charge
 i=400;
 while(i--) j++;
 PORTD=0x00;      // and off again;

 //init timer2
 TCCR2 = 0x00;	 	// normal-mode , prescale = 0 <- not start timer yet!!
}//end of init_pwm()

inline void stop_pwm(void)
{
 TIMSK &= 0x3F;	//disable Timer/Counter2  Interrupts
 //PORTD  = 0x00;   //turn off all fets
 TCCR2  = 0x00;   //stop timer , prescaler =0
}

inline void start_pwm(void)
{
 PWM_BYTE_ON  = Pwm_Byte & 0x0F; // lower nibble holds on-pattern
 if(Pwm_Width < PWM_TOP)
  {
   PWM_BYTE_OFF = Pwm_Byte >>4;  // higer nibble holds off-pattern
  }
 else
  {
   PWM_BYTE_OFF = PWM_BYTE_ON;
  }
 PWM_PORT=PWM_BYTE_ON;				   //start with fets on

 OCR2=Pwm_Width;

 TCNT2  = 0x0000; //start with full cycle
 TIFR  |= 0xC0;   //clear pending irqs
 TIMSK |= 0xC0;   //Timer/Counter2 Output Compare Match and Overflow Interrupt Enable
 TCCR2 |=1;       //start the timer
}// end of void start_pwm()























